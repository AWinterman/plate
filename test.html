<!doctype html><meta charset="utf8">
    <title>platoon tests</title>
    <body></body>
    <script>
(function() {
    var get_exports = function(file) {
        var where = window,
            what = file == 'index' ? [] : file.split('/'),
            incoming;
        what.unshift('plate');
        while(what.length) {
            incoming = what.shift();
            if(!where[incoming]) {
                where[incoming] = {};
            }
            where = where[incoming];
        }
        return where;
    };

    (function(exports){try { plate.tz } catch(e) { }

var SafeString = function(str) {
  this.str = str
  this.isSafe = true
}

SafeString.prototype.toString = function() {
  return this.str
}

var escapeHTML = function(data) {
  if(data.isSafe) return data

  var html = data.toString()
  html = html.replace(/\&/g, '&amp;').
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;').
    replace(/"/g, '&quot;').
    replace(/'/g, '&#39;')

  return new SafeString(html)
}

exports.escapeHTML = escapeHTML
exports.SafeString = SafeString
exports.format = format
exports.time_format = time_format
exports.Formatter = Formatter
exports.DateFormat = DateFormat
exports.TimeFormat = TimeFormat

function capfirst (str) {
  return str.replace(/^(.{1})/, function(a, m) { return m.toUpperCase() })
}

function map (arr, iter) {
  var out = []
  for(var i = 0, len = arr.length; i < len; ++i)
    out.push(iter(arr[i], i, arr))
  return out
}

function reduce(arr, iter, start) {
  arr = arr.slice()
  if(start !== undefined)
    arr.unshift(start)

  if(arr.length === 0)
    throw new Error('reduce of empty array')

  if(arr.length === 1)
    return arr[0]

  var out = arr.slice()
    , item = arr.shift()

  do {
    item = iter(item, arr.shift())
  } while(arr.length)

  return item
}

var WEEKDAYS = [ 'sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday' ]
  , WEEKDAYS_ABBR = map(WEEKDAYS, function(x) { return [].slice.call(x).slice(0, 3).join('') })
  , WEEKDAYS_REV = reduce(map(WEEKDAYS, function(x, i) { return [x, i] }), function(lhs, rhs) { lhs[rhs[0]] = rhs[1]; return lhs }, {})
  , MONTHS = [ 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december' ]
  , MONTHS_3 = map(MONTHS, function(x) { return [].slice.call(x).slice(0, 3).join('') })
  , MONTHS_3_REV = reduce(map(MONTHS_3, function(x, i) { return [x, i] }), function(lhs, rhs) { lhs[rhs[0]] = rhs[1]; return lhs }, {})
  , MONTHS_AP = [
    'Jan.'
  , 'Feb.'
  , 'March'
  , 'April'
  , 'May'
  , 'June'
  , 'July'
  , 'Aug.'
  , 'Sept.'
  , 'Oct.'
  , 'Nov.'
  , 'Dec.'
  ]


var MONTHS_ALT = {
  1: 'January',
  2: 'February',
  3: 'March',
  4: 'April',
  5: 'May',
  6: 'June',
  7: 'July',
  8: 'August',
  9: 'September',
  10: 'October',
  11: 'November',
  12: 'December'
}

function Formatter(t) {
  this.data = t
}

Formatter.prototype.format = function(str) {
  var bits = [].slice.call(str)
  , esc = false
  , out = []
  , bit

  while(bits.length) {
    bit = bits.shift()

    if(esc) {
      out.push(bit)
      esc = false
    } else if(bit === '\\') {
      esc = true
    } else if(this[bit]) {
      out.push(this[bit]())
    } else {
      out.push(bit)
    }
  }

  return out.join('')
}

function TimeFormat(t) {
  Formatter.call(this, t)
}

var proto = TimeFormat.prototype = new Formatter()

proto.a = function() {
  // 'a.m.' or 'p.m.'
  if (this.data.getHours() > 11)
    return 'p.m.'
  return 'a.m.'
}

proto.A = function() {
  // 'AM' or 'PM'
  if (this.data.getHours() > 11)
    return 'PM'
  return 'AM'
}

proto.f = function() {
  /*
  Time, in 12-hour hours and minutes, with minutes left off if they're
  zero.
  Examples: '1', '1:30', '2:05', '2'
  Proprietary extension.
  */
  if (this.data.getMinutes() == 0)
    return this.g()
  return this.g() + ":" + this.i()
}

proto.g = function() {
  // Hour, 12-hour format without leading zeros i.e. '1' to '12'
  var h = this.data.getHours()

  return this.data.getHours() % 12 || 12
}

proto.G = function() {
  // Hour, 24-hour format without leading zeros i.e. '0' to '23'
  return this.data.getHours()
}

proto.h = function() {
  // Hour, 12-hour format i.e. '01' to '12'
  return ('0'+this.g()).slice(-2)
}

proto.H = function() {
  // Hour, 24-hour format i.e. '00' to '23'
  return ('0'+this.G()).slice(-2)
}

proto.i = function() {
  // Minutes i.e. '00' to '59'
  return ('0' + this.data.getMinutes()).slice(-2)
}

proto.P = function() {
  /*
  Time, in 12-hour hours, minutes and 'a.m.'/'p.m.', with minutes left off
  if they're zero and the strings 'midnight' and 'noon' if appropriate.
  Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'
  Proprietary extension.
  */
  var m = this.data.getMinutes()
    , h = this.data.getHours()

  if (m == 0 && h == 0)
    return 'midnight'
  if (m == 0 && h == 12)
    return 'noon'
  return this.f() + " " + this.a()
}

proto.s = function() {
  // Seconds i.e. '00' to '59'
  return ('0'+this.data.getSeconds()).slice(-2)
}

proto.u = function() {
  // Microseconds
  return this.data.getMilliseconds()
}

// DateFormat

function DateFormat(t) {
  this.data = t
  this.year_days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
}

proto = DateFormat.prototype = new TimeFormat()

proto.contructor = DateFormat

proto.b = function() {
  // Month, textual, 3 letters, lowercase e.g. 'jan'
  return MONTHS_3[this.data.getMonth()]
}

proto.c= function() {
  /*
  ISO 8601 Format
  Example : '2008-01-02T10:30:00.000123'
  */
  return this.data.toISOString()
}

proto.d = function() {
  // Day of the month, 2 digits with leading zeros i.e. '01' to '31'
  return ('0'+this.data.getDate()).slice(-2)
}

proto.D = function() {
  // Day of the week, textual, 3 letters e.g. 'Fri'
  return capfirst(WEEKDAYS_ABBR[this.data.getDay()])
}

proto.E = function() {
  // Alternative month names as required by some locales. Proprietary extension.
  return MONTHS_ALT[this.data.getMonth()+1]
}

proto.F= function() {
  // Month, textual, long e.g. 'January'
  return capfirst(MONTHS[this.data.getMonth()])
}

proto.I = function() {
  // '1' if Daylight Savings Time, '0' otherwise.
  return this.data.isDST() ? '1' : '0'
}

proto.j = function() {
  // Day of the month without leading zeros i.e. '1' to '31'
  return this.data.getDate()
}

proto.l = function() {
  // Day of the week, textual, long e.g. 'Friday'
  return capfirst(WEEKDAYS[this.data.getDay()])
}

proto.L = function() {
  // Boolean for whether it is a leap year i.e. True or False
  // Selects this year's February 29th and checks if the month
  // is still February.
  return (new Date(this.data.getFullYear(), 1, 29).getMonth()) === 1
}

proto.m = function() {
  // Month i.e. '01' to '12'"
  return ('0'+(this.data.getMonth()+1)).slice(-2)
}

proto.M = function() {
  // Month, textual, 3 letters e.g. 'Jan'
  return capfirst(MONTHS_3[this.data.getMonth()])
}

proto.n = function() {
  // Month without leading zeros i.e. '1' to '12'
  return this.data.getMonth() + 1
}

proto.N = function() {
  // Month abbreviation in Associated Press style. Proprietary extension.
  return MONTHS_AP[this.data.getMonth()]
}

proto.O = function() {
  // Difference to Greenwich time in hours e.g. '+0200'

  var tzoffs = this.data.getTimezoneOffset()
    , offs = ~~(tzoffs / 60)
    , mins = ('00' + ~~Math.abs(tzoffs % 60)).slice(-2)
  
  return ((tzoffs > 0) ? '-' : '+') + ('00' + Math.abs(offs)).slice(-2) + mins
}

proto.r = function() {
  // RFC 2822 formatted date e.g. 'Thu, 21 Dec 2000 16:01:07 +0200'
  return this.format('D, j M Y H:i:s O')
}

proto.S = function() {
  /* English ordinal suffix for the day of the month, 2 characters i.e. 'st', 'nd', 'rd' or 'th' */
  var d = this.data.getDate()

  if (d >= 11 && d <= 13)
    return 'th'
  var last = d % 10

  if (last == 1)
    return 'st'
  if (last == 2)
    return 'nd'
  if (last == 3)
    return 'rd'
  return 'th'
}

proto.t = function() {
  // Number of days in the given month i.e. '28' to '31'
  // Use a javascript trick to determine the days in a month
  return 32 - new Date(this.data.getFullYear(), this.data.getMonth(), 32).getDate()
}

proto.T = function() {
  // Time zone of this machine e.g. 'EST' or 'MDT'
  if(this.data.tzinfo) {
    return this.data.tzinfo().abbr || '???'
  }
  return '???'
}

proto.U = function() {
  // Seconds since the Unix epoch (January 1 1970 00:00:00 GMT)
  // UTC() return milliseconds frmo the epoch
  // return Math.round(this.data.UTC() * 1000)
  return ~~(this.data / 1000)
}

proto.w = function() {
  // Day of the week, numeric, i.e. '0' (Sunday) to '6' (Saturday)
  return this.data.getDay()
}

proto.W = function() {
  // ISO-8601 week number of year, weeks starting on Monday
  // Algorithm from http://www.personal.ecu.edu/mccartyr/ISOwdALG.txt
  var jan1_weekday = new Date(this.data.getFullYear(), 0, 1).getDay() 
    , weekday = this.data.getDay()
    , day_of_year = this.z()
    , week_number
    , i = 365

  if(day_of_year <= (8 - jan1_weekday) && jan1_weekday > 4) {
    if(jan1_weekday === 5 || (jan1_weekday === 6 && this.L.call({data:new Date(this.data.getFullYear()-1, 0, 1)}))) {
      week_number = 53
    } else {
      week_number = 52
    }
  } else {
    if(this.L()) {
      i = 366
    }
    if((i - day_of_year) < (4 - weekday)) {
      week_number = 1
    } else {
      week_number = ~~((day_of_year + (7 - weekday) + (jan1_weekday - 1)) / 7)
      if(jan1_weekday > 4)
        week_number -= 1
    }
  }
  return week_number
}

proto.y = function() {
  // Year, 2 digits e.g. '99'
  return (''+this.data.getFullYear()).slice(-2)
}

proto.Y = function() {
  // Year, 4 digits e.g. '1999'
  return this.data.getFullYear()
}

proto.z = function() {
  // Day of the year i.e. '0' to '365'

  doy = this.year_days[this.data.getMonth()] + this.data.getDate()
  if (this.L() && this.data.getMonth() > 1)
    doy += 1
  return doy
}

proto.Z = function() {
  /*
  Time zone offset in seconds (i.e. '-43200' to '43200'). The offset for
  timezones west of UTC is always negative, and for those east of UTC is
  always positive.
  */
  return this.data.getTimezoneOffset() * -60
}


function format(value, format_string) {
  df = new DateFormat(value)
  return df.format(format_string)
}


function time_format(value, format_string) {
  tf = new TimeFormat(value)
  return tf.format(format_string)
}
})(get_exports("utils"));
(function(exports){var clear_stack = function(fn) {
  setTimeout(fn, 0);
};

if(typeof(window) !== 'undefined') {

  var setZeroTimeout = function(fn) {
    window.addEventListener('message', function event_listener(ev) {
      window.removeEventListener('message', event_listener, true);

      if(ev.source === window && ev.data === 'zero-timeout') {
        ev.stopPropagation();
        try{ fn(); } catch(err) {}
      }
    }, true);

    window.postMessage('zero-timeout', '*'); 
  };

  if('postMessage' in window && 'addEventListener' in window)
    clear_stack = setZeroTimeout;
  else
    clear_stack = function(fn){fn();};
}

exports.eterator = function eterator (list) {
  var _l = list.slice();
  var ret = function(block) {
    block.next = function() {
      if(_l.length) {
        var next = _l.shift();
        eterator.clear_stack(function() {
          block(next);   
        });
      } else {
        block.done();
      }
    };
    block.done = function() {
      ret.finish();
    };

    eterator.clear_stack(block.next);
  };
  ret.on_ready = function(ready) {
    ret.finish = ready;
  };
  return ret;
};

exports.eterator.clear_stack = clear_stack

exports.parallel = function(list, ready) {
  var _l = list.slice(),
      expecting = _l.length,
      accum = [],
      seen = 0;

  var collect = function(idx, err, data) {
    if(err) {
      // quit the second an error occurs
      // prevent error events from recalling `ready`
      ready(err);
      collect = function(){}
    } else {
      ++seen;
      accum[idx] = data;
      if(seen === expecting) {
        ready(null, accum)
      }
    }
  };

  return function(fn) {
    for(var i = 0, len = _l.length; i < len; ++i) {
      (function(node, idx) {
        fn(node, function(err, data) {
          collect(idx, err, data);
        }); 
      })(_l[i], i) 
    }
    if(_l.length === 0)
      ready(null, [])
  };
};
})(get_exports("eterator"));
(function(exports){var utils = plate.utils,
    eterator = plate.eterator,
    parallel = eterator.parallel,
    eterator = eterator.eterator,
    slice = [].slice;

var Node = function() {
    this.init && this.init.apply(this, slice.call(arguments));
};

Node.prototype.toString = function() {
    return this.__name__;
};

var FilterNode = function(filtervar) {
    this.filtervar = filtervar;  
};

FilterNode.prototype.__name__ = 'FILTER';

FilterNode.prototype = new Node;

FilterNode.prototype.render = function(context, ready) {
  this.filtervar(context, function(err, data) {
    if(err) { ready(null, ''); } else {
      data = data === undefined || data === null ? '' : data;
      data = !data.isSafe ? 
          utils.escapeHTML(data+'') :
          data+'';
      ready(null,data);
    }
  });
};

var NodeList = function(nodes) {
    this.nodes = nodes;
};

NodeList.prototype.getNodesByType = function(type) {
    var output = [];
    for(var i = 0, len = this.nodes.length; i < len; ++i) {
        if(this.nodes[i] instanceof type) {
            output.push(this.nodes[i]);
        }
    }
    return output;
};

NodeList.prototype.render = function(context, callback) {
    var list = parallel(this.nodes, function(err, output) {
        err ?
          callback(err) :
          callback(null, output.join(''));
    })

    list(function(node, done) {
      node.render(context.copy(), done);
    });

};

exports.Node = Node;
exports.FilterNode = FilterNode;
exports.NodeList = NodeList;
})(get_exports("nodes"));
(function(exports){var nodes = plate.nodes,
    utils = plate.utils,
    NodeList = nodes.NodeList,
    Node = nodes.Node,
    BLOCK_CONTEXT_KEY = 'block_context';

var BlockContext = function() {
    this.blocks = {};
};

BlockContext.prototype.addBlocks = function(blocks) {
    var self = this,
        pushOrCreate = function(name, block) {
        if(self.blocks[name]) {
            self.blocks[name].unshift(block);
        } else {
            self.blocks[name] = [block];
        }
    };

    for(var name in blocks) {
        pushOrCreate(name, blocks[name]);
    }
};

BlockContext.prototype.pop = function(name) {
    if(this.blocks[name]) {
      return this.blocks[name].pop();
    } else return null;
};

BlockContext.prototype.push = function(name, block) {
    this.blocks[name].push(block);
};

BlockContext.prototype.getBlock = function(name) {
    if(this.blocks[name]) {
        return this.blocks[name].slice(-1)[0];
    }
    return null;
};

var BlockNode = function(name, nodelist) {
  this.name = name;
  this.nodelist = nodelist;  
};

BlockNode.prototype = new Node;
BlockNode.prototype.render = function(context, ready) {
    var self = this,
        blockContext = context[BLOCK_CONTEXT_KEY];
    if(blockContext) {
        var block, push;
        push = block = blockContext.pop(this.name);
        if(!block) {
            block = this;
        }
        block = new BlockNode(block.name, block.nodelist);
        block.context = context;
        block.context['block'] = block;
        context.block = block;
        block.nodelist.render(context, function(err, data) {
            if(push) {
                blockContext.push(self.name, push);
            }
            ready(err, data);
        });
    } else {
        context.block = this;
        this.nodelist.render(context, ready);
    }
};

BlockNode.prototype._super = function(ready) {
    if(this.context[BLOCK_CONTEXT_KEY] && this.context[BLOCK_CONTEXT_KEY].getBlock(this.name)) {
        this.context[BLOCK_CONTEXT_KEY].getBlock(this.name).render(this.context, function(err, data) {
          err ?
            ready(err) :
            ready(null, new utils.SafeString(data))
        })
    } else {
        ready(null, '');
    }
};

BlockNode.parse = function(contents, parser) {
    var bits = contents.split(/\s+/g),
        blockName = bits[1],
        loadedBlocks = parser.__loadedBlocks || [];

    for(var i = 0, len = loadedBlocks.length; i < len; ++i) {
        if(loadedBlocks[i] === blockName) {
            throw new Error("block tag with name '"+blockName+"' appears more than once");
        }
    }
    loadedBlocks.push(blockName);
    parser.__loadedBlocks = loadedBlocks;

    var nodeList = parser.parse(['endblock']);
    parser.tokens.shift();

    return new BlockNode(blockName, nodeList);
};

exports.BlockNode = BlockNode;
exports.BlockContext = BlockContext;
exports.BLOCK_CONTEXT_KEY = BLOCK_CONTEXT_KEY;
})(get_exports("tags/block"));
(function(exports){var nodes = plate.nodes,
    Node = nodes.Node,
    blocktag = plate.tags.block,
    BlockContext = blocktag.BlockContext,
    BlockNode = blocktag.BlockNode,
    BLOCK_CONTEXT_KEY = blocktag.BLOCK_CONTEXT_KEY;

var ExtendsNode = function(parent_expr, nodelist, loader_plugin) {
    this.parent_expr = parent_expr;
    this.nodelist = nodelist;
    this.loader_plugin = loader_plugin;
    var blocks = this.nodelist.getNodesByType(BlockNode),
        outblocks = {};
    for(var i = 0, len = blocks.length; i < len; ++i) {
        outblocks[blocks[i].name] = blocks[i];
    }
    this.blocks = outblocks;
};

ExtendsNode.prototype = new Node;
ExtendsNode.prototype.render = function(context, callback) {
    var self = this,
        platelib = plate;
    self.parent_expr(context, function(err, tpl) {
        if(err) {
            callback(err, null);
        } else {
            var fn = tpl instanceof platelib.Template ? function(tpl, callback) { callback(null, tpl); } :
                     function(tpl, callback) { self.loader_plugin(tpl, callback); };
            fn(tpl, function(err, template) {
                if(!context[BLOCK_CONTEXT_KEY]) {
                    context[BLOCK_CONTEXT_KEY] = new BlockContext();
                }
                var blockContext = context[BLOCK_CONTEXT_KEY];
                blockContext.addBlocks(self.blocks);
                var blocks = {},
                    nodeList = template.getNodeList();
                for(var i = 0, len = nodeList.nodes.length; i < len; ++i) {
                    var node = nodeList.nodes[i];
                    if(!(node instanceof ExtendsNode)) {
                        var nodes = nodeList.getNodesByType(BlockNode),
                            outnodes = {};
                        for(var j = 0, jlen = nodes.length; j < jlen; ++j) {
                            outnodes[nodes[j].name] = nodes[j];
                        }
                        blockContext.addBlocks(outnodes);
                        break;
                    }
                }
                template.render(context, callback);
            });
        }
    });
};

ExtendsNode.parse = function(contents, parser) {
    var bits = contents.split(/\s+/g),
        parent = parser.compileFilter(bits[1]),
        nodelist = parser.parse();
    var loader = null;
    try {
        loader = parser.pluginLibrary.lookup('loader');
    } catch(err) {}

    return new ExtendsNode(parent, nodelist, loader);
};

exports.ExtendsNode = ExtendsNode;
})(get_exports("tags/_extends"));
(function(exports){var nodes = plate.nodes,
    eterator = plate.eterator.eterator,
    NodeList = nodes.NodeList,
    Node = nodes.Node;

var ForNode = function(from, to, inner, outer, reversed) {
    this.from = from;
    this.to = to;
    this.inner = inner;
    this.outer = outer;
    this.reversed = reversed;
};

ForNode.prototype = new Node;
ForNode.prototype.render = function(context, callback) {
    var self = this,
        parentloop = {};

    if(context.forloop) {
        for(var name in context.forloop) if(context.forloop.hasOwnProperty(name)) {
            parentloop[name] = context.forloop[name];
        }
    }

    self.from(context, function(err, values) {
        if(err) {
            callback(err, null);
        } else {
            if(self.reversed) {
                values = [].reverse.call([].slice.call(values));
            }
            if(values && values.length) {

                var eter = eterator(values),
                    accum = [],
                    error,
                    it;

                eter.on_ready(function() {
                    error ?
                        callback(error, null) :
                        callback(null, accum.join(''));
                });

                eter(it=function(value) {
                    var ctxt = self.createContext(context, parentloop, value, accum.length, values.length);
                    self.inner.render(ctxt, function(err, data) {
                        if(err) {
                            error = err;
                            it.done();
                        } else {
                            accum.push(data);
                            it.next();
                        }
                    });
                });
            } else {
                self.outer.render(context, callback); 
            }
        }
    });
};

ForNode.prototype.createContext = function(ctxt, parentloop, values, index, length) {
    var output = ctxt.copy();
    if(this.to.length > 1) {
        for(var i = 0, len = this.to.length; i < len; ++i) {
            ctxt[this.to[i]] = values[i];
        }
    } else {
        ctxt[this.to[0]] = values;
    }

    var forLoop = {
            counter:index+1,
            counter0:index,
            revcounter:length-index,
            revcounter0:length-(index+1),
            first:index == 0,
            last:index == (length-1),
            parentloop:parentloop
        };
    ctxt.forloop = forLoop;
    return ctxt;
};

// {% for (x | x, y...) in (var) [reversed] %} 
ForNode.parse = function(contents, parser) {
    var bits = contents.replace(/\s*$/,'').split(/\s+/g),
        reversed = bits.slice(-1)[0] === 'reversed',
        in_index = (function() { 
            for(var i = 0, len = bits.length; i < len; ++i) {
                if(bits[i] == 'in') { return i; }
            }
            throw new Error("for tag must include 'in'");
        })(),
        variable_bits = bits.slice(1, in_index),
        unpack = [],
        arrayVar = parser.compileFilter(bits[in_index+1]),
        nodelist = parser.parse(['empty', 'endfor']),
        empty = new NodeList([]);


    if(parser.tokens.shift().isOneOf(['empty'])) {
        empty = parser.parse(['endfor']);
        parser.tokens.shift();
    } 

    for(var i = 0, len = variable_bits.length; i < len; ++i) {
        var innerbits = variable_bits[i].split(',');

        for(var j = 0, jlen = innerbits.length; j < jlen; ++j) {
            if(innerbits[j].length > 0) {
                unpack.push(innerbits[j]);
            }
        }
    }

    return new ForNode(arrayVar, unpack, nodelist, empty, reversed);
};

exports.ForNode = ForNode;
})(get_exports("tags/_for"));
(function(exports){var nodes = plate.nodes,
    NodeList = nodes.NodeList,
    Node = nodes.Node;

var keys = Object.keys instanceof Function ? 
                function(obj) { return Object.keys(obj); } :
                function(obj) {
                    var accum = []; 
                    for(var n in obj) if(obj.hasOwnProperty(n)) {
                        accum.push(n);
                    }
                    return accum; 
                };

var InfixOperator = function(bp, cmp) {
    this.lbp = bp;
    this.cmp = cmp;
}; 

InfixOperator.prototype.nud = function(parser) {
    throw new Error("Unexpected token");
};

InfixOperator.prototype.led = function(lhs, parser) {
    this.first = lhs;
    this.second = parser.expression(this.lbp);
    return this;
};

InfixOperator.prototype.evaluate = function(context, callback) {
    var self = this;
    self.first.evaluate(context, function(err, x) {
        self.second.evaluate(context, function(err, y) {
            callback(err, self.cmp(x, y));
        });
    }); 
};

var PrefixOperator = function(bp, cmp) {
    this.lbp = bp;
    this.cmp = cmp;
};

PrefixOperator.prototype.nud = function(parser) {
    this.first = parser.expression(this.lbp);
    this.second = null;
    return this;
};

PrefixOperator.prototype.led = function(first, parser) {
    throw new Error("Unexpected token");
};

PrefixOperator.prototype.evaluate = function(context, callback) {
    var self = this;
    self.first.evaluate(context, function(err, x) {
        callback(err, self.cmp(x));
    });
};

var LiteralToken = function(value, original) {
    this.lbp = 0;
    this.value = value;
    this.original = original;
};

LiteralToken.prototype.toString = function() {
    return '<LiteralToken: "'+this.original+'">';
};

LiteralToken.prototype.nud = function(parser) {
    return this;
};

LiteralToken.prototype.led = function() {
    throw new Error();
};

LiteralToken.prototype.evaluate = function(context, callback) {
    this.value(context, callback);
};

var EndToken = function() {
    this.lbp = 0;
};

EndToken.prototype.nud = EndToken.prototype.led = function() { throw new Error(); }

var operators = {
    or: function() {
        return new InfixOperator(6, function(x, y) {
                return x || y;
        });
    },
    and: function() {
        return new InfixOperator(7, function(x, y) {
                return x && y;
        });
    },
    not: function() {
        return new PrefixOperator(8, function(x) {
            return !x;
        });
    },
    'in': function() {
        return new InfixOperator(9, function(x, y) {
            if(!(x instanceof Object) && y instanceof Object) {
                y = keys(y);
            }

            if(typeof(x) == 'string' && typeof(y) =='string') {
                return y.indexOf(x) !== -1;
            }

            for(var found = false, i = 0, len = y.length; i < len && !found; ++i) {
                var rhs = y[i];
                if(x instanceof Array) {
                    for(var idx = 0,
                        equal = x.length == rhs.length,
                        xlen = x.length;
                        idx < xlen && equal; ++idx) {

                        equal = (x[idx] === rhs[idx]);
                    }
                    found = equal;
                } else if(x instanceof Object) {
                    if(x === rhs) {
                        return true;
                    }
                    var xkeys = keys(x),
                        rkeys = keys(rhs);

                    if(xkeys.length === rkeys.length) { 
                        for(var i = 0, len = xkeys.length, equal = true;
                            i < len && equal;
                            ++i) {
                            equal = xkeys[i] === rkeys[i] &&
                                    x[xkeys[i]] === rhs[rkeys[i]];
                        }
                        found = equal;
                    } 
                } else {
                    found = x == rhs;
                }
            }
            return found;
        });
    },
    'not in': function() {
        return new InfixOperator(9, function(x, y) {
            return !operators['in']().cmp(x,y);
        });
    },
    '=': function() {
        return new InfixOperator(10, function(x, y) { 
            return x == y;
        });
    },
    '==': function() {
        return new InfixOperator(10, function(x, y) { 
            return x == y;
        });
    },
    '!=': function() {
        return new InfixOperator(10, function(x, y) { 
            return x !== y;
        });
    },
    '>': function() {
        return new InfixOperator(10, function(x, y) { 
            return x > y;
        });
    },
    '>=': function() {
        return new InfixOperator(10, function(x, y) { 
            return x >= y;
        });
    },
    '<': function() {
        return new InfixOperator(10, function(x, y) { 
            return x < y;
        });
    },
    '<=': function() {
        return new InfixOperator(10, function(x, y) { 
            return x <= y;
        });
    }
};

var IfParser = function(tokens, parser) {
    this.createVariable = function(token) {
        return new LiteralToken(parser.compileFilter(token), token);
    };

    var len = tokens.length,
        i = 0,
        mappedTokens = [],
        token;
    while(i < len) {
        token = tokens[i];
        if(token == 'not' && tokens[i+1] == 'in') {
            ++i;
            token = 'not in';
        }
        mappedTokens.push(this.translateToken(token));
        ++i;
    }
    this.tokens = mappedTokens;
    this.pos = 0;
    this.currentToken = this.next();
};

IfParser.prototype.translateToken = function(token) {
    var op = operators[token];
    if(op === undefined) {
        return this.createVariable(token);
    } else {
        return op();
    }
};

IfParser.prototype.next = function() {
    if(this.pos >= this.tokens.length) {
        return new EndToken();
    }
    return this.tokens[this.pos++];
};

IfParser.prototype.parse = function() {
    var retval = this.expression();
    if(!(this.currentToken instanceof EndToken)) {
        throw new Error("Unused "+this.currentToken+" at end of if expression.");
    }
    return retval; 
};

IfParser.prototype.expression = function(rbp) {
    rbp = rbp || 0;
    var t = this.currentToken,
        left;
    this.currentToken = this.next();

    left = t.nud(this);
    while(rbp < this.currentToken.lbp) {
        t = this.currentToken;
        this.currentToken = this.next();
        left = t.led(left, this);
    }
    return left;
};

var IfNode = function(predicate, ifTrue, ifFalse) {
    this.predicate = predicate;
    this.ifTrue = ifTrue;
    this.ifFalse = ifFalse;
};

IfNode.prototype = new Node;
IfNode.prototype.render = function(context, callback) {
    var self = this;
    self.predicate.evaluate(context, function(err, data) {
        if(err) {
            callback(err, null);
        } else {
            var which = data ? self.ifTrue : self.ifFalse;
            which.render(context.copy(), callback);
        }
    });
};

IfNode.parse = function(contents, parser) {
    var bits = contents.split(/\s+/g).slice(1),
        ifparser = new IfParser(bits, parser),
        variable = ifparser.parse(),
        ifTrue = parser.parse(['else', 'endif']),
        nextToken = parser.tokens.shift(),
        ifFalse = nextToken.isOneOf(['else']) ? (function() { 
            var ret = parser.parse(['endif']);
            parser.tokens.shift();
            return ret;
        })() : new NodeList([]);
    return new IfNode(variable, ifTrue, ifFalse);
};

exports.IfNode = IfNode;
})(get_exports("tags/_if"));
(function(exports){var nodes = plate.nodes,
    NodeList = nodes.NodeList,
    Node = nodes.Node;

var IncludeNode = function(templatevar, loader) {
    this.templatevar = templatevar;
    this.loader = loader;
};
IncludeNode.prototype = new Node;
IncludeNode.prototype.render = function(context, callback) {
    var self = this,
        platelib = plate;
    self.templatevar(context, function(ctxt, tpl) {
        var fn = tpl instanceof platelib.Template ? 
            function(tpl, callback) { callback(null, tpl); } :
            self.loader;

        fn(tpl, function(err, template) {
            template.render(context, callback);
        });
    });
};

IncludeNode.parse = function(contents, parser) {
    var bits = contents.split(/\s+/g),
        templatevar = parser.compileFilter(bits[1]),
        loader;
    try {
        loader = parser.pluginLibrary.lookup('loader');
    } catch(err){}

    return new IncludeNode(templatevar, loader);
};

exports.IncludeNode = IncludeNode;
})(get_exports("tags/include"));
(function(exports){var nodes = plate.nodes,
    format = plate.utils.format,
    Node = nodes.Node;

var NowNode = function(str) {
  this.format = str
};
NowNode.prototype = new Node;
NowNode.prototype.newDate = function() { return new Date }

NowNode.prototype.render = function(context, ready) {
  ready(null, format(this.newDate(), this.format))
};

NowNode.parse = function(contents, parser) {
    var bits = contents.split(' '),
        fmt = bits.slice(1).join(' ')

    fmt = fmt.replace(/^\s*/, '')
             .replace(/\s*$/, '')

    fmt.charAt(0) in {'"':1, "'":1} && 
      (fmt = fmt.slice(1));

    fmt.charAt(fmt.length-1) in {'"':1, "'":1} &&
      (fmt = fmt.slice(0, -1));

    return new NowNode(fmt || 'N j, Y')
};

exports.NowNode = NowNode;

})(get_exports("tags/now"));
(function(exports){var nodes = plate.nodes,
    NodeList = nodes.NodeList,
    Node = nodes.Node;

var WithNode = function(withvar, asvar, nodelist) {
    this.withvar = withvar;
    this.asvar = asvar;
    this.nodelist = nodelist;
};
WithNode.prototype = new Node;
WithNode.prototype.render = function(context, callback) {
    var self = this;
    self.withvar(context, function(err, data) {
        if(err) {
            callback(err, null);
        } else {
            context[self.asvar] = data;

            self.nodelist.render(context, callback);
        }
    });
};

WithNode.parse = function(contents, parser) {
    var bits = contents.split(/\s+/g),
        withvar = parser.compileFilter(bits[1]),
        asvar = bits[3],
        nodelist = parser.parse(['endwith']);

    parser.tokens.shift();
    return new WithNode(withvar, asvar, nodelist);
};

exports.WithNode = WithNode;
})(get_exports("tags/_with"));
(function(exports){var nodes = plate.nodes,
    Node = nodes.Node;

var CommentNode = function(nodelist) {
    this.nodelist = nodelist;
};

CommentNode.prototype = new Node;
CommentNode.prototype.render = function(context, callback) { callback(null, ''); };

CommentNode.parse = function(contents, parser) {
    var nodelist = parser.parse(['endcomment']);

    parser.tokens.shift();
    return new CommentNode(nodelist);
};

exports.CommentNode = CommentNode;
})(get_exports("tags/comment"));
(function(exports){exports.add = function(callback, input, value) {
    callback(null, parseInt(input, 10) + parseInt(value, 10));
};
})(get_exports("filters/add"));
(function(exports){exports.addslashes = function(callback, input) {
    callback(null, input.toString().replace(/'/g, "\\'"));
};
})(get_exports("filters/addslashes"));
(function(exports){exports.capfirst = function(callback, input) {
    var str = input.toString();
    callback(null, [str.slice(0,1).toUpperCase(), str.slice(1)].join(''));
};
})(get_exports("filters/capfirst"));
(function(exports){exports.center = function(callback, input, len, value) {
    var str = input.toString();
    value = value || ' ';
    len -= str.length;
    if(len < 0) { 
        callback(null, str);
    } else {
        var len_half = len/2.0,
            arr = [],
            idx = Math.floor(len_half);
        while(idx-- > 0) {
            arr.push(value);
        }
        arr = arr.join('');
        str = arr + str + arr;
        if((len_half - Math.floor(len_half)) > 0) {
            str = input.toString().length % 2 == 0 ? value + str : str + value;
        }
        callback(null, str);
    }
};
})(get_exports("filters/center"));
(function(exports){exports.cut = function(callback, input, value) {
    var str = input.toString();
    callback(null, str.replace(new RegExp(value, "g"), ''));
};
})(get_exports("filters/cut"));
(function(exports){var format = plate.utils.format
  
exports.date = function(callback, input, value) {
    if (value === undefined)
        value = 'N j, Y';
    callback(null, format(input.getFullYear ? input : new Date(input), value));
}
})(get_exports("filters/date"));
(function(exports){exports._default = function(callback, input, def) {
    input ? callback(null, input) : callback(null, def);
};
})(get_exports("filters/_default"));
(function(exports){exports.dictsort = function(callback, input, key) {
    callback(null, input.sort(function(x, y) {
        if(x[key] > y[key]) return 1;
        if(x[key] == y[key]) return 0;
        if(x[key] < y[key]) return -1;
    }));
};
})(get_exports("filters/dictsort"));
(function(exports){var dictsort = plate.filters.dictsort.dictsort;

exports.dictsortreversed = function(callback, input, key) {
    dictsort(function(err, result) {
        if(err) { 
            callback(err, null);
        } else {
            callback(null, result.reverse()); 
        }
    }, input, key);
};
})(get_exports("filters/dictsortreversed"));
(function(exports){exports.divisibleby = function(callback, input, num) {
    callback(null, input % parseInt(num, 10) == 0);
};
})(get_exports("filters/divisibleby"));
(function(exports){var utils = plate.utils;

exports.escape = function(callback, input) {
    callback(null, utils.escapeHTML(input))
};
})(get_exports("filters/escape"));
(function(exports){var utils = plate.utils;

exports.force_escape = function(callback, input) {
    callback(null, utils.escapeHTML(''+input))
};
})(get_exports("filters/_force_escape"));
(function(exports){exports.filesizeformat = function(callback, input) {
    var num = (new Number(input)).valueOf(),
        singular = num == 1 ? '' : 's',
        value = num < 1024 ? num + ' byte'+singular :
                num < (1024*1024) ? (num/1024)+' KB' :
                num < (1024*1024*1024) ? (num / (1024*1024)) + ' MB' :
                num / (1024*1024*1024) + ' GB';
    callback(null, value);
};
})(get_exports("filters/filesize_format"));
(function(exports){exports.first = function(callback, input) {
    callback(null, input[0]);
};
})(get_exports("filters/first"));
(function(exports){exports.floatformat = function(callback, input, val) {
    val = parseInt(val, 10);
    val = isNaN(val) ? -1 : val;

    var isPositive = val >= 0,
        asNumber = parseFloat(input),
        absValue = Math.abs(val),
        pow = Math.pow(10, absValue),
        pow_minus_one = Math.pow(10, Math.max(absValue-1, 0)),
        asString;

    asNumber = Math.round((pow * asNumber) / pow_minus_one);
    if(val !== 0)
      asNumber /= 10;

    asString = asNumber.toString();

    if(isPositive) {
        var split = asString.split('.'),
            decimal = split.length > 1 ? split[1] : '';

        while(decimal.length < val) {
            decimal += '0';
        }

        asString = decimal.length ? [split[0], decimal].join('.') : split[0];
    }

    callback(null, asString);
};
})(get_exports("filters/float_format"));
(function(exports){exports.get_digit = function(callback, input, digit) {
  var isNum = !isNaN(parseInt(input, 10)),
      str = input.toString(),
      len = str.split('').length;

  digit = parseInt(digit, 10);
  if(isNum && !isNaN(digit) && digit <= len) {
    callback(null, str.charAt(len - digit));
  } else {
    callback(null, input);
  }
};
})(get_exports("filters/get_digit"));
(function(exports){})(get_exports("filters/index"));
(function(exports){exports.iteritems = function(callback, input) {
  var output = [];
  for(var name in input) if(input.hasOwnProperty(name)) {
    output.push([name, input[name]]);
  }
  callback(null, output);
};
})(get_exports("filters/iteritems"));
(function(exports){exports.iriencode = function(callback, input) {
  callback(null, input);
};
})(get_exports("filters/iriencode"));
(function(exports){exports.join = function(callback, input, glue) {
  input = input instanceof Array ? input : input.toString().split('');
  callback(null, input.join(glue));
};
})(get_exports("filters/join"));
(function(exports){exports.last = function(callback, input) {
  var cb = input.charAt || function(ind) { return input[ind]; };
  callback(null, cb.call(input, input.length-1));
};
})(get_exports("filters/last"));
(function(exports){exports.length = function(callback, input) {
  var cb = input.length instanceof Function ? input.length : function(lambda) {
    lambda(null, input.length);
  };
  cb.apply(input, [function(err, len) {
    callback(null, len);
  }]);
};
})(get_exports("filters/length"));
(function(exports){var length = plate.filters.length.length;

exports.length_is = function(callback, input, expected) {
  length(function(err, val) {
    callback(err, parseInt(val, 10) === parseInt(expected, 10));
  }, input);
};
})(get_exports("filters/length_is"));
(function(exports){var utils = plate.utils;

exports.linebreaks = function(callback, input) {
  var str = input.toString(),
      paras = str.split('\n\n'),
      out = [];

  while(paras.length) {
    out.unshift(paras.pop().replace(/\n/g, '<br />'));
  }
  callback(null, new utils.SafeString('<p>'+out.join('</p><p>')+'</p>')); 
};
})(get_exports("filters/linebreaks"));
(function(exports){var utils = plate.utils;

exports.linebreaksbr = function(callback, input) {
  var str = input.toString();
  callback(null, new utils.SafeString(str.replace(/\n/g, '<br />')));
};
})(get_exports("filters/linebreaksbr"));
(function(exports){exports.linenumbers = function(callback, input) {
  var str = input.toString(),
      bits = str.split('\n'),
      out = [],
      len = bits.length;

  while(bits.length) out.unshift(len - out.length + '. ' + bits.pop());

  callback(null, out.join('\n'));
};
})(get_exports("filters/linenumbers"));
(function(exports){exports.ljust = function(callback, input, num) {
  var bits = (input === null || input === undefined ? '' : input).toString().split(''),
      difference = num - bits.length;

  // push returns new length of array.
  while(difference > 0) difference = num - bits.push(' ');

  callback(null, bits.join(''));
};
})(get_exports("filters/ljust"));
(function(exports){exports.lower = function(callback, input) {
  callback(null, input.toString().toLowerCase());
};
})(get_exports("filters/lower"));
(function(exports){exports.make_list = function(callback, input) {
  input = input instanceof Array ? input : input.toString().split('');

  callback(null, input);
};
})(get_exports("filters/make_list"));
(function(exports){
var LETTERS = {
'a': '2', 'b': '2', 'c': '2', 'd': '3', 'e': '3',
'f': '3', 'g': '4', 'h': '4', 'i': '4', 'j': '5', 'k': '5', 'l': '5',
'm': '6', 'n': '6', 'o': '6', 'p': '7', 'q': '7', 'r': '7', 's': '7',
't': '8', 'u': '8', 'v': '8', 'w': '9', 'x': '9', 'y': '9', 'z': '9'
};

exports.phone2numeric = function(callback, input) {
  var str = input.toString().toLowerCase().split(''),
      out = [],
      ltr;

  while(str.length) {
    ltr = str.pop();
    out.unshift(LETTERS[ltr] ? LETTERS[ltr] : ltr);
  }

  callback(null, out.join(''));
};
})(get_exports("filters/phone2numeric"));
(function(exports){var length = plate.filters.length.length;

exports.pluralize = function(callback, input, plural) {
  plural = (plural || 's').split(',');
  var suffix,
      val = Number(input);

  if(val === 1) {
    suffix = plural.length > 1 ? plural[0] : '';    
  } else {
    suffix = plural[plural.length-1];
  }
  callback(null, suffix);
};
})(get_exports("filters/pluralize"));
(function(exports){var length = plate.filters.length.length;

exports.random = function(callback, input) {
  var cb = input.charAt || function(idx) {
    return this[idx];
  };

  length(function(err, val) {
      callback(null, cb.apply(input, [Math.floor(Math.random() * val)]));
  }, input);
};
})(get_exports("filters/random"));
(function(exports){exports.rjust = function(callback, input, num) {
  var bits = (input === null || input === undefined ? '' : input).toString().split(''),
      difference = num - bits.length;

  // push returns new length of array.
  while(difference > 0) difference = num - bits.unshift(' ');

  callback(null, bits.join(''));
};

})(get_exports("filters/rjust"));
(function(exports){var utils = plate.utils;

exports.safe = function(callback, input) {
    callback(null, new utils.SafeString(input));
};
})(get_exports("filters/safe"));
(function(exports){exports.slice = function(callback, input, by) {
  by = by.toString();
  if(by.charAt(0) === ':') {
    by = '0'+by; 
  }
  if(by.charAt(by.length-1) === ':') {
    by = by.slice(0, -1);
  }

  var splitBy = by.split(':'),
    slice = input.slice || (function() {
      input = this.toString();
      return input.slice;
    })();

  callback(null, slice.apply(input, splitBy));
};
})(get_exports("filters/slice"));
(function(exports){exports.slugify = function(callback, input) {
  input = input.toString();
  callback(null, input.replace(/[^\w\s\d\-]/g, '').replace(/^\s*/, '').replace(/\s*$/, '').replace(/[\-\s]+/g, '-').toLowerCase());
};
})(get_exports("filters/slug_ify"));
(function(exports){exports.striptags = function(callback, input) {
  var str = input.toString();
  callback(null, str.replace(/<[^>]*?>/g, ''));
};
})(get_exports("filters/striptags"));
(function(exports){exports.title = function(callback, input) {
  var str = input.toString(),
      bits = str.split(/\s{1}/g),
      out = [];
  
  while(bits.length) {
    var word = bits.pop();
    word = word.charAt(0).toUpperCase() + word.slice(1);
    out.push(word);
  }
  out = out.join(' ');
  callback(null, out.replace(/([a-z])'([A-Z])/g, function() { return arguments[2].toLowerCase(); }));
};
})(get_exports("filters/title"));
(function(exports){exports.timesince = function(callback, input, n) {
  var input = new Date(input)
    , now   = n ? new Date(n) : new Date()
    , diff  = input - now
    , since = Math.abs(diff)

  if(diff > 0)
    return callback(null, '0 minutes')

  // 365.25 * 24 * 60 * 60 * 1000 === years
  var years =   ~~(since / 31557600000)
    , months =  ~~((since - (years*31557600000)) / 2592000000)
    , days =    ~~((since - (years * 31557600000 + months * 2592000000)) / 86400000)
    , hours =   ~~((since - (years * 31557600000 + months * 2592000000 + days * 86400000)) / 3600000)
    , minutes = ~~((since - (years * 31557600000 + months * 2592000000 + days * 86400000 + hours * 3600000)) / 60000)
    , result = [
        years   ? pluralize(years,    'year') : null
      , months  ? pluralize(months,   'month') : null
      , days    ? pluralize(days,     'day') : null
      , hours   ? pluralize(hours,    'hour') : null
      , minutes ? pluralize(minutes,  'minute') : null
    ]
    , out = []

  for(var i = 0, len = result.length; i < len; ++i) {
    result[i] !== null && out.push(result[i])
  }

  if(!out.length) {
    return callback(null, '0 minutes')
  }

  return callback(null, out[0] + (out[1] ? ', ' + out[1] : ''))

  function pluralize(x, str) {
    return x + ' ' + str + (x === 1 ? '' : 's')
  }
}
})(get_exports("filters/timesince"));
(function(exports){
var timesince = plate.filters.timesince.timesince

exports.timeuntil = function(callback, input, n) {
  var now = n ? new Date(n) : new Date()
  return timesince(callback, now, input)

}
})(get_exports("filters/timeuntil"));
(function(exports){exports.truncatewords = function(callback, input, n) {
  var str = input.toString(),
      num = parseInt(n, 10);

  if(isNaN(num)) return callback(null, input);
  callback(null, input.split(/\s+/).slice(0, num).join(' ')+'...');
};
})(get_exports("filters/truncatewords"));
(function(exports){exports.truncatechars = function(callback, input, n) {
  var str = input.toString(),
      num = parseInt(n, 10);

  if(isNaN(num)) return callback(null, input);
  callback(null, input.slice(0, num)+'...');
};
})(get_exports("filters/truncatechars"));
(function(exports){var utils = plate.utils;

var ulparser = function(list) {
  var out = [],
      l = list.slice(),
      item;

  while(l.length) {
    item = l.pop();
    if(item instanceof Array) out.unshift('<ul>'+ulparser(item)+'</ul>');
    else out.unshift('</li><li>'+item);
  }

  // get rid of the leading </li>, if any. add trailing </li>.
  return out.join('').replace(/^<\/li>/, '') + '</li>';
};

exports.unordered_list = function(callback, input) {
  callback(null, input instanceof Array ? new utils.SafeString(ulparser(input)) : input);
};
})(get_exports("filters/unordered_list"));
(function(exports){exports.upper = function(callback, input) {
  callback(null, input.toString().toUpperCase());
};
})(get_exports("filters/upper"));
(function(exports){exports.urlencode = function(callback, input) {
  callback(null, escape(input.toString()));
};
})(get_exports("filters/urlencode"));
(function(exports){var utils = plate.utils;

exports.urlize = function(callback, input) {
  var str = input.toString();
  callback(null, new utils.SafeString(str.replace(/(((http(s)?:\/\/)|(mailto:))([\w\d\-\.:@\/])+)/g, function() {
    return '<a href="'+arguments[0]+'">'+arguments[0]+'</a>'; 
  })));
};
})(get_exports("filters/urlize"));
(function(exports){var utils = plate.utils;

exports.urlizetrunc = function(callback, input, len) {
  var str = input.toString();
  len = parseInt(len, 10) || 1000;
  callback(null, new utils.SafeString(str.replace(/(((http(s)?:\/\/)|(mailto:))([\w\d\-\.:@])+)/g, function() {
    var ltr = arguments[0].length > len ? arguments[0].slice(0, len) + '...' : arguments[0];
    return '<a href="'+arguments[0]+'">'+ltr+'</a>'; 
  })));
};

})(get_exports("filters/urlizetrunc"));
(function(exports){exports.wordcount = function(callback, input) {
  var str = input.toString(),
      bits = str.split(/\s+/g);
  callback(null, bits.length);
};
})(get_exports("filters/wordcount"));
(function(exports){exports.wordwrap = function(callback, input, len) {
  var words = input.toString().split(/\s+/g),
      out = [],
      len = parseInt(len, 10) || words.length;

  while(words.length) {
    out.unshift(words.splice(0, len).join(' '));
  };
  callback(null, out.join('\n'));
};
})(get_exports("filters/wordwrap"));
(function(exports){exports.yesno = function(callback, input, map) {
  var ourMap = map.toString().split(','),
      value;

  ourMap.length < 3 && ourMap.push(ourMap[1]);

  value = ourMap[input ? 0 :
                 input === false ? 1 :
                 2];

  callback(null, value);
};
})(get_exports("filters/yesno"));
(function(exports){var Library = function() {
    this.registry = {};
};

Library.prototype.lookup = function(name) {
    if(this.registry[name]) {
        return this.registry[name];
    }
    throw new Error("Could not find " + name + " !");
};

Library.prototype.register = function(name, item) {
    if(this.registry[name]) {
        throw new Error(name + " is already registered!");
    }
    this.registry[name] = item;
};

var DefaultTagLibrary = function() {
    this.registry = (function() {
        var F = function(){};
        F.prototype = DefaultTagLibrary.default_library;
        return new F;
    })();
};

DefaultTagLibrary.prototype = new Library();

DefaultTagLibrary.default_library = {
    'with':plate.tags._with.WithNode.parse,
    'for':plate.tags._for.ForNode.parse,
    'if':plate.tags._if.IfNode.parse,
    'extends':plate.tags._extends.ExtendsNode.parse,
    'block':plate.tags.block.BlockNode.parse,
    'include':plate.tags.include.IncludeNode.parse,
    'now':plate.tags.now.NowNode.parse,
    'comment':plate.tags.comment.CommentNode.parse
};

var DefaultFilterLibrary = function() {
    this.registry = (function() {
        var F = function(){};
        F.prototype = DefaultFilterLibrary.default_library;
        return new F;
    })();
};

DefaultFilterLibrary.prototype = new Library();

DefaultFilterLibrary.default_library = {
    'add':plate.filters.add.add,
    'addslashes':plate.filters.addslashes.addslashes,
    'capfirst':plate.filters.capfirst.capfirst,
    'center':plate.filters.center.center,
    'cut':plate.filters.cut.cut,
    'date':plate.filters.date.date,
    'default':plate.filters._default._default,
    'dictsort':plate.filters.dictsort.dictsort,
    'dictsortreversed':plate.filters.dictsortreversed.dictsortreversed,
    'divisibleby':plate.filters.divisibleby.divisibleby,
    'escape':plate.filters.escape.escape,
    'filesizeformat':plate.filters.filesize_format.filesizeformat,
    'first':plate.filters.first.first,
    'floatformat':plate.filters.float_format.floatformat,
    'force_escape':plate.filters._force_escape.force_escape,
    'get_digit':plate.filters.get_digit.get_digit,
    'index':plate.filters.index.index,
    'iteritems':plate.filters.iteritems.iteritems,
    'iriencode':plate.filters.iriencode.iriencode,
    'join':plate.filters.join.join,
    'last':plate.filters.last.last,
    'length':plate.filters.length.length,
    'length_is':plate.filters.length_is.length_is,
    'linebreaks':plate.filters.linebreaks.linebreaks,
    'linebreaksbr':plate.filters.linebreaksbr.linebreaksbr,
    'linenumbers':plate.filters.linenumbers.linenumbers,
    'ljust':plate.filters.ljust.ljust,
    'lower':plate.filters.lower.lower,
    'make_list':plate.filters.make_list.make_list,
    'phone2numeric':plate.filters.phone2numeric.phone2numeric,
    'pluralize':plate.filters.pluralize.pluralize,
    'random':plate.filters.random.random,
    'rjust':plate.filters.rjust.rjust,
    'safe':plate.filters.safe.safe,
    'slice':plate.filters.slice.slice,
    'slugify':plate.filters.slug_ify.slugify,
    'striptags':plate.filters.striptags.striptags,
    'timesince':plate.filters.timesince.timesince,
    'timeuntil':plate.filters.timeuntil.timeuntil,
    'title':plate.filters.title.title,
    'truncatechars':plate.filters.truncatechars.truncatechars,
    'truncatewords':plate.filters.truncatewords.truncatewords,
    'unordered_list':plate.filters.unordered_list.unordered_list,
    'upper':plate.filters.upper.upper,
    'urlencode':plate.filters.urlencode.urlencode,
    'urlize':plate.filters.urlize.urlize,
    'urlizetrunc':plate.filters.urlizetrunc.urlizetrunc,
    'wordcount':plate.filters.wordcount.wordcount,
    'wordwrap':plate.filters.wordwrap.wordwrap,
    'yesno':plate.filters.yesno.yesno
};

exports.Library = Library;
exports.DefaultTagLibrary = DefaultTagLibrary;
exports.DefaultFilterLibrary = DefaultFilterLibrary;
exports.DefaultPluginLibrary = Library;
})(get_exports("libraries"));
(function(exports){var nodes = plate.nodes,
    NodeList = nodes.NodeList,
    eterator = plate.eterator.eterator;

var Parser = function(tokens, tagLib, filterLib, pluginLib) {
    this.tokens = tokens;
    this.tagLibrary = tagLib;
    this.filterLibrary = filterLib;
    this.pluginLibrary = pluginLib;
}; 

Parser.prototype.parse = function(parse_until_these) {
    var nodes_out = [],
        token = null;

    while(this.tokens.length > 0) {
        token = this.tokens.shift();
        if(token) {
            if(parse_until_these && token.isOneOf(parse_until_these)) {
                this.tokens.unshift(token);
                return new NodeList(nodes_out);
            } else {
                nodes_out.push(token.createNode(this));
            }
        }
    };
    if(parse_until_these) {
        throw new Error("Expected one of '"+parse_until_these.join("', '")+"'");
    }
    return new NodeList(nodes_out);
};

var createStringResolver = function(content) {
    return function(context) { return function(args, callback) { callback(null, content); }; };
};

var createNumberResolver = function(content) {
    return function(context) { return function(args, callback) { callback(null, new Number(content).valueOf()); }; };
};

var createContextResolver = function(pieces) {
    return function(context) {
        return function(args, ready) {
            var okay = function(x) { return x !== undefined && x !== null; },
                callable = function(fn) {
                    return typeof(fn) === 'function';
                },
                eter = eterator(pieces),
                current = context,
                error,
                it;

            eter.on_ready(function() {
                error ?
                    ready(error, null) :
                    ready(null, current);
            });

            eter(it=function(piece) {
              try {
                  var prev = current;

                  piece = piece === 'super' ? '_super' : piece;
                  current = current[piece];

                  if(!okay(current)) {
                      // this attribute ended up being undefined or null, we're out
                      it.done();
                  } else {
                      // if this attribute is okay, we check to see if it's callable or a straight-up value.
                      var okay_continue = !callable(current);

                      // it's not okay to automatically continue if we're a callable.
                      if(!okay_continue) {
                          var tmp;
                          var ret = current.call(prev, tmp=function(err, data) {
                              if(err) {
                                  // the callable emitted an error, so we store it and exit.
                                  error = err;
                                  it.done(); 
                              } else {
                                  // otherwise we get this show on the road.
                                  current = data;
                                  it.next();
                              }  
                          });

                          // if it didn't return undefined or null, it's okay to continue, and we store the return value in ``current``.
                          if(okay_continue=okay(ret)) {
                              current = ret;
                          }
                      }
                     
                      // it's okay to continue if ``current`` is scalar, or if the callable returned a scalar value.
                      if(okay_continue) {
                          it.next();
                      }
                  } 
              } catch(err) {
                  // trying to grab the next item off the list triggered an error
                  // OR calling a client callable context variable triggered an error
                  // so we store the error and exit.
                  error = err || new Error();
                  it.done();
              }
            });
        };
    };
};

var createBaseResolver = function(content) {
    if(content.charAt(0) in {'"':true, "'":true}) {
        return createStringResolver(content.slice(1,-1));
    } else if(/^[\d\.]*$/.test(content)) {
        return createNumberResolver(content);
    } else {
        return createContextResolver(content.split('.'));
    }
};

var createFilterResolver = function(filter_fn, args) {
    return function(context) {
        return function(input, ready) {
            var eter = eterator(args),
                values = [],
                error,
                it;

            eter.on_ready(function() {
              if(error) ready(error, null)
              else {
                  values = [ready, input].concat(values);
                  filter_fn.apply({}, values);
              }
            });
          
            eter(it=function(filtervar) {
                filtervar(context, function(err, data) {
                    if(err) {
                        error = err;
                        it.done();
                    } else {
                        values.push(data);
                        it.next();
                    }
                });
            });
        };
    };
};

Parser.prototype.compileFilter = function(content) {
    content = content.replace(/^\s*/g,'').replace(/\s*$/g, '');
    var self = this;
    var pipe_split = content.split('|'),
        filter_chain = (function (items) {
            var output = [],
                item_split = [];
            for(var i = 0, len = items.length; i < len; ++i) {
                item_split = items[i].split(':');
                for(var j = 1, arglen = item_split.length; j < arglen; ++j) {
                    item_split[j] = self.compileFilter(item_split[j]);
                }
                output.push(i == 0 ? 
                            createBaseResolver(item_split[0]) :
                            createFilterResolver(
                                self.filterLibrary.lookup(item_split[0]),
                                item_split.slice(1) 
                            )
                );
            }
            return output;
        })(pipe_split),
        resolve = function(context, callback) {
            var eter = eterator(filter_chain),
                error,
                value,
                it;

            eter.on_ready(function() {
                error ? 
                    callback(error, null) :
                    callback(null, value);
            });

            eter(it=function(filtervar) {
                filtervar(context)(value, function(err, data) {
                    if(err) {
                        error = err;
                        it.done();
                    } else {
                        value = data;
                        it.next();
                    }
                });
            });
        };

    resolve.original = content;
    return resolve;
};

exports.Parser = Parser;
})(get_exports("parsers"));
(function(exports){var nodes = plate.nodes,
    FilterNode = nodes.FilterNode;

var Token = function(content, lineNumber) {
    this.content = content;
    this.lineNumber = lineNumber;
    this.name = this.content.split(/\s+/g)[0];
};

Token.prototype.toString = function() {
    return '<'+this.repr+': "'+this.content.slice(0,20)+'">';
};

Token.prototype.isOneOf = function(names) {
    if(this.isTag()) {
        for(var i = 0, len = names.length; i < len; ++i) {
            if(this.name == names[i]) {
                return true;
            }
        }
    }
    return false;
};

Token.prototype.createNode = function(parser) {
    return this.creationFunction(this.content, parser);
};

Token.prototype.isTag = function() { return false; };

Token.subclass = function(proto) {
    var F = function() {},
        SC = function() {
            Token.apply(this, Array.prototype.slice.call(arguments));
        };
    F.prototype = Token.prototype;
    SC.prototype = new F();
    for(var name in proto) if(proto.hasOwnProperty(name)) {
        SC.prototype[name] = proto[name];
    }
    return SC;
};

var TextToken = Token.subclass({
    creationFunction:function(content, parser) {
        return {
            render:function(context, callback) {
                callback(null, content);
            }
        };
    },
    repr:'TextToken'
});

var TagToken = Token.subclass({
    creationFunction:function(content, parser) {
        var ttag = parser.tagLibrary.lookup(this.name)(content.replace(/^\s*/, '').replace(/\s*$/, ''), parser);
        ttag.__name__ = this.name;
        return ttag;
    },
    isTag:function() { return true; },
    repr:'TagToken'
});

var FilterToken = Token.subclass({
    creationFunction:function(content, parser) {
        var filtervar = parser.compileFilter(content);
        return new FilterNode(filtervar);
    },
    repr:'FilterToken'
});

var CommentToken = Token.subclass({
    creationFunction:function(content, parser) {
        return {
            render:function(context, callback) {
                callback(null, '');
            }
        }; 
    },
    repr:'CommentToken'
});

exports.CommentToken = CommentToken;
exports.FilterToken = FilterToken;
exports.TagToken = TagToken;
exports.TextToken = TextToken;
exports.Token = Token;
})(get_exports("tokens"));
(function(exports){var tokens = plate.tokens,
    parsers = plate.parsers,
    libraries = plate.libraries;

var Context = function(dict) {
    if(dict) {
        for(var name in dict) if(dict.hasOwnProperty(name)) {
            this[name] = dict[name];
        }
    }
};

Context.prototype.copy = function() {
    var sup = function(){},
        cpy;

    sup.prototype = this;
    return new sup; 
};

var Template = function(raw, libs, parser) {
    if(typeof(raw) !== 'string') {
        throw new TypeError("You must pass in a string to render the template.");
    }
    this.raw = raw;
    libs = libs || {};
    this.tag_library = libs.tag_library || Template.Meta.createTagLibrary();
    this.filter_library = libs.filter_library || Template.Meta.createFilterLibrary();
    this.plugin_library = libs.plugin_library || Template.Meta.createPluginLibrary();
    this.parser = parser || parsers.Parser;
};

Template.Meta = {
  _autoregister:{plugin:{}, tag:{}, filter:{}},
  _classes:{plugin:libraries.DefaultPluginLibrary,tag:libraries.DefaultTagLibrary,filter:libraries.DefaultFilterLibrary},
  _cache:{}
};

var createGetLibraryMethod = function(name) {
  return function() {
    if(this._cache[name])
      return this._cache[name]; 

    var lib = new this._classes[name];
    for(var key in this._autoregister[name]) if(this._autoregister[name].hasOwnProperty(key)) {
      lib.register(key, this._autoregister[name][key]);
    }

    this._cache[name] = lib;
    return lib;
  };
};

var createSetAutoregisterMethod = function(name) {
  return function(key, item) {
    if(this._cache[name])
      this._cache[name].register(key, item);
    else
      this._autoregister[name][key] = item;
  };
};

Template.Meta.createPluginLibrary = createGetLibraryMethod('plugin');
Template.Meta.createFilterLibrary = createGetLibraryMethod('filter');
Template.Meta.createTagLibrary = createGetLibraryMethod('tag');
Template.Meta.registerPlugin = createSetAutoregisterMethod('plugin');
Template.Meta.registerFilter = createSetAutoregisterMethod('filter');
Template.Meta.registerTag = createSetAutoregisterMethod('tag');
  
Template.createPluginLibrary = function() {
  return new libraries.DefaultPluginLibrary();
};

Template.prototype.getNodeList = function() {
    if(!this.tokens) {
        this.tokens = Template.tokenize(this.raw);
    }

    if(!this.nodelist) {
        var parser = new this.parser(
            this.tokens,
            this.tag_library,
            this.filter_library,
            this.plugin_library,
            this);
        this.nodelist = parser.parse();
    }

    return this.nodelist;
};

Template.prototype.render = function(context, callback) {
    if(typeof(context) !== 'object') {
        throw new TypeError("You must pass in an instance of Object or plate.Context");
    }

    try {
        if(!(context instanceof Context)) {
            context = new Context(context);
        }
        this.getNodeList();
        this.nodelist.render(context, callback);
    } catch(err) {
        callback(err, null);
    }
};


var MATCH_RE = /\{[%#\{](.*?)[\}#%]\}/g;

Template.tokenize = function(original) {
    var raw = original.slice(),
        match = null,
        map = {
            '%':tokens.TagToken,
            '#':tokens.CommentToken,
            '{':tokens.FilterToken
        },
        tokens_out = [],
        lineNo = 1,
        repl_re = /[^\n]*/gm,
        incLineNo = function(str) {
            lineNo += str.replace(repl_re, '').length;
        };

    do {
        MATCH_RE.lastIndex = 0;
        match = MATCH_RE.exec(raw);
        if(match) {
            var str = raw.slice(0, match.index);
            incLineNo(str);
            if(match.index > 0) {
                tokens_out.push(new tokens.TextToken(str));
            }

            var token_data = match[1].replace(/^\s+/g, '').replace(/\s+$/g, ''),
                token_cls = map[match[0].charAt(1)];

            tokens_out.push(new token_cls(token_data, lineNo));
            raw = raw.slice(match.index+match[0].length);
        }
    } while(match);
    if(raw) {
        tokens_out.push(new tokens.TextToken(raw));
    }
    return tokens_out;
};

exports.Context = Context;
exports.Template = Template;
})(get_exports("index"));
})();
</script>
<script>;(function() {

// so, the only way we (reliably) get access to DST in javascript
// is via `Date#getTimezoneOffset`.
//
// this value will switch for a given date based on the presence or absence
// of DST at that date.

function find_dst_threshold (near, far) {
  var near_date = new Date(near)
    , far_date = new Date(far)
    , near_offs = near_date.getTimezoneOffset()
    , far_offs = far_date.getTimezoneOffset()

  if(near_offs === far_offs) return 0

  if(Math.abs(near_date - far_date) < 1000) return near_date

  return find_dst_threshold(near, near+(far-near)/2) || find_dst_threshold(near+(far-near)/2, far)
}


function find_dst_thresholds() {
  var d = new Date()
    , d = new Date(d.getFullYear(), 0, 1)
    , f = new Date(d.getFullYear(), 11, 31)
    , x
    , first
    , second

  x = (f - d) / -2
  first = find_dst_threshold(+d, d - x)
  second = find_dst_threshold(d - x, +f)

  return {
    spring_forward  : first ? (first.getTimezoneOffset() < second.getTimezoneOffset() ? second : first) - new Date(d.getFullYear(), 0, 1, 0, 0) : 0
  , fall_back       : first ? (first.getTimezoneOffset() < second.getTimezoneOffset() ? first : second) - new Date(d.getFullYear(), 0, 1, 0, 0) : 0
  }
}

var THRESHOLDS = find_dst_thresholds()

function is_dst(datetime, thresholds) {

  thresholds = thresholds || THRESHOLDS

  if(thresholds.spring_forward === thresholds.fall_back)
    return false

  var offset = datetime - new Date(datetime.getFullYear(), 0, 1, 0, 0)
    , dst_is_reversed = thresholds.spring_forward > thresholds.fall_back
    , max = Math.max(thresholds.fall_back, thresholds.spring_forward)
    , min = Math.min(thresholds.fall_back, thresholds.spring_forward)

  if(min < offset && offset < max)
    return !dst_is_reversed
  return dst_is_reversed
}

Date.prototype.isDST = function(thresholds) {
  return is_dst(this, thresholds) 
}

is_dst.find_thresholds = find_dst_thresholds

if(typeof module !== 'undefined') {
  module.exports = is_dst
} else {
  window.is_dst = is_dst 
}

})()
</script>
    <script>(function(global) {
    var TestCase = function(name, setup, teardown, testFns) {
        this.name = name;
        this.setUp = setup || function(cb) { cb() };
        this.tearDown = teardown || function(cb) { cb() };
        this.testFns = testFns;
    };

    // if a test waits for >30s, we abort it.
    TestCase.TIMEOUT = 30000;
    var Fail = {};

    var AssertionSet = function(name, fn, against) {
        this.name = name;
        this.fn = fn;

        this.against = against || {};
        this.pending = 0;
        this.passes = [];
        this.failures = [];
        this.errors = [];
    };

    AssertionSet.prototype.passed = function() {
      return this.failures.length === 0 && this.errors.length === 0;
    };

    AssertionSet.prototype.throwFail = function(fail) {
      this.failures.push(fail);
      throw Fail;
    };

    AssertionSet.prototype.execute = function(callback) {
        var self = this,
            started = +new Date,
            timeout = function () {
                if(self.pending > 0) {
                  if((+new Date)-started < TestCase.TIMEOUT)
                    setTimeout(timeout, 0);
                  else {
                    self.errors.push(['timed out', [], new Error()]);
                  }
                } else {
                    callback();
                }
            };
        try {
            self.fn.apply(self.against, [self]);
        } catch(err) {
            if(err !== Fail)
              self.errors.push(err);
        }
        setTimeout(timeout, 0);
    };

    AssertionSet.prototype.async = function(callback) {
        ++this.pending;
        var self = this,
            currentAgainst = self.against;
        return function() {
            --self.pending;
            try {
              return callback.apply(self.against, [].slice.call(arguments));
            } catch(err) {
              if(err !== Fail)
                self.errors.push(err);
            }
        };
    };

    AssertionSet.prototype.deepEqual = function(lhs, rhs, reentrant) {
        reentrant = reentrant !== undefined;
        var lhsKeys = [],
            rhsKeys = [],
            name = null;
        for(name in lhs) if(lhs.hasOwnProperty(name)) {
            lhsKeys.push(name);
        }
        for(name in rhs) if(rhs.hasOwnProperty(name)) {
            rhsKeys.push(name);
        }
        if(rhsKeys.length !== lhsKeys.length) {
            this.throwFail(['should deep equal', [lhs, rhs], new Error()]);
        } else {
            var failureLength = this.failures.length;
            for(var i = 0, len = lhsKeys.length; i < len; ++i) {
                var lhsObject = lhs[lhsKeys[i]],
                    rhsObject = rhs[rhsKeys[i]];
                if(lhsObject == rhsObject) {
                    continue;
                } else {
                    if(lhsObject instanceof Object && rhsObject instanceof Object) {
                        arguments.callee.apply(this, [lhsObject, rhsObject, true]);
                        if(failureLength !== this.failures.length) {
                            break;
                        }
                    } else {
                        this.throwFail(['should deep equal', [lhs, rhs], new Error()]);
                        break;
                    }
                }
            }
            if(failureLength === this.failures.length && !reentrant) {
                this.passes.push(['should deep equal', [lhs, rhs], new Error()]);
            }
        }
    };

    AssertionSet.prototype.ok = function(rhs) {
        var msg = ['should be truth-y', [rhs], new Error()];
        (rhs) ?
            this.passes.push(msg) :
            this.throwFail(msg);
    };

    AssertionSet.prototype.fail = function(rhs) {
        var msg = ['should be false-y', [rhs], new Error()];
        (rhs) ?
            this.throwFail(msg) : 
            this.passes.push(msg);
    };

    AssertionSet.prototype.equal = function(lhs, rhs) {
        var msg = ['should ==', [lhs, rhs], new Error()];
        (rhs == lhs) ?
            this.passes.push(msg) :
            this.throwFail(msg);
    };

    AssertionSet.prototype.notEqual = function(lhs, rhs) {
        var msg = ['should !=', [lhs, rhs], new Error()];
        (rhs == lhs) ?
            this.throwFail(msg) : 
            this.passes.push(msg);
    };

    AssertionSet.prototype.strictEqual = function(lhs, rhs) {
        var msg = ['should ===', [lhs, rhs], new Error()];
        (rhs === lhs) ?
            this.passes.push(msg) :
            this.throwFail(msg);
    };

    AssertionSet.prototype.strictNotEqual = function(lhs, rhs) {
        var msg = ['should !==', [lhs, rhs], new Error()];
        (rhs === lhs) ?
            this.throwFail(msg) :
            this.passes.push(msg);
    };

    AssertionSet.prototype.isInstance = function(lhs, class_list) {
        if(!(class_list instanceof Array)) {
            class_list = [class_list];
        }
        for(var i = 0, len = class_list.length; i < len; ++i) {
            if(lhs instanceof class_list[i]) {
                this.passes.push(['should instanceof', [lhs, class_list]]);
                return;
            }
        }
        this.throwFail(['should instanceof', [lhs, class_list], new Error()]);
    };

    AssertionSet.prototype.throws = function(error_class, fn) {
        if(!(error_class instanceof Array)) {
            error_class = [error_class];
        }
        try {
            fn.apply(arguments[2], [].slice.call(arguments, 2));
            this.throwFail(['should throw', [error_class, fn], new Error()]);
        } catch(err) {
            for(var i = 0, len = error_class.length; i < len; ++i) {
                if(err instanceof error_class[i]) {
                    this.passes.push(['should throw', [error_class, fn, err]]);
                    return;
                }
            }
            this.throwFail(['should throw', error_class.concat([fn]), new Error()]);
        }
    };

    AssertionSet.prototype.doesNotThrow = function(fn) {
        try {
            fn.apply(arguments[1], [].slice.call(arguments, 1));
            this.passes.push(['should not throw', [fn, null]]);
        } catch(err) {
            this.throwFail(['should not throw', [fn, err], new Error()]);
        }
    };

    TestCase.prototype.runTests = function(against, callback) {
        var self = this,
            i = -1,
            len = self.testFns.length,
            assertionSets = [],
            recurseTests = function() {
                ++i;
                var currentFunction = self.testFns[i];
                if(i >= len) {
                    return;
                }
                self.setUp(function() {
                    var assertionSet = new AssertionSet(self.getDocString(currentFunction), currentFunction, against);
                    assertionSet.execute(function() {
                        self.tearDown(function() {
                            assertionSets.push(assertionSet);
                            recurseTests();
                        });
                    });
                });
            },
            timeoutFunction = function() {
                if(assertionSets.length !== self.testFns.length) {
                    setTimeout(arguments.callee, 0);
                } else {
                    callback(self, assertionSets);
                }
            };
        recurseTests();
        setTimeout(timeoutFunction, 0);
    };

    TestCase.prototype.getDocString = function(fn) {
        if(fn.__doc__) return fn.__doc__;

        var re = /function\s*(.*?)\s*{\s*('(.*?)'|"(.*?)")/;
        var match = re.exec(fn.toSource ? fn.toSource() : fn.toString()),
            docstring = match ? match[2].slice(1, -1) : null;
        re.lastIndex = 0;
        fn.name = docstring;
        return docstring;
    };


    global.unit = function(opts) {
        var testFns = [].slice.call(arguments, 1),
            test = function(name) {
            return new TestCase(name, opts.setup, opts.teardown, testFns);
        };
        test.classname = 'platoon.TestCase';
        return test;
    };


    function HTMLTestRunner() {
      this.tests = {}
      this.pre = document.createElement('PRE')

      document.body.appendChild(this.pre)
    }

    var proto = HTMLTestRunner.prototype

    proto.make = function(name) {
      return (this.tests[name] = (this.tests[name] || {}))
    }

    proto.write = function(what) {
      var text = this.pre.innerHTML
        , last
        , lines
      text += what


      lines = text.split('\n')
      last = lines[lines.length-1]


      lines[lines.length - 1] =
        last.length > 80
          ? last.slice(0, 79) + '\n' + last.slice(79)
          : last
      this.pre.innerHTML = lines.join('\n')
    }

    proto.run = function() {
      var self = this
        , tests = []
        , finished = []
        , make_test = function(instance) {
            ret.instance = instance

            return ret
            function ret(ready) {
              instance.runTests({}, ready)
            }
          }
      for(var file in this.tests) {
        for(var unit in this.tests[file]) {
          tests.push(make_test(this.tests[file][unit](file + ': '+unit)))
        }
      }

      function accumulate(testcase, assertionset, next) {
        if(testcase) {
          for(var i = 0, set; set = assertionset[i]; ++i) {
            if(set.errors.length) self.write('E')
            else if(set.failures.length) self.write('F')
            else self.write('.')
          }
          finished.push({
              'testcase':testcase
            , 'assertionset':assertionset
          })
        }

        next = tests.shift()
        if(next) {
            return setTimeout(function() { next(accumulate) }, 0)
        }
        finish()
      }

      function finish() {
        for(var i = 0, len = finished.length; i < len; ++i) {
          var test = finished[i].testcase
            , sets = finished[i].assertionset

          for(var j = 0, set; set = sets[j]; ++j) {
            if(set.errors.length || set.failures.length) {
              self.write('\n in '+test.name+': '+set.name+'\n')
            }

            for(var x = 0, err; err = set.errors[x]; ++x) {
              self.write(err.stack ? err + '\n' + err.stack : err)
            }
            for(var x = 0, err; err = set.failures[x]; ++x) {
              self.write(err.stack ? err + '\n' + err.stack : err)
            }

          }
        }
      }
      platoon.beforeStart(accumulate)
    }


    global.makeHTMLTestRunner = function() {
      return new HTMLTestRunner()
    }

    global.beforeStart = function(ready) { ready(); };
    global.beforeFinish = function(ready) { ready(); };

    global.setBeforeStart = function(fn) { global.beforeStart = fn; };
    global.setBeforeFinish = function(fn) { global.beforeFinish = fn; };

    global.test = function(name, fn) {
        fn.__doc__ = name;
        return fn;
    };
    global.TestCase = TestCase;
    global.AssertionSet = AssertionSet;
})(typeof window === 'undefined' ? exports : (window.platoon = {}));
</script>
    <script>(function(testrunner) {;(function (require, exports) {

return;

    ;if(typeof window === 'undefined') {
  var plate = require('../index')
    , utils = require('../lib/utils')
    , platoon = require('platoon')
} else {
  var plate = window.plate
    , platoon = window.platoon
  var utils = plate.utils
}

Function.prototype.bind = Function.prototype.bind || function(obj) {
  var self = this
    , args = [].slice.call(arguments, 1)

  return function() {
    return self.apply(obj, args.concat([].slice.call(arguments)))
  }
}

Array.prototype.forEach = [].forEach || function(fn) {
  for(var i = 0, len = this.length; i < len; ++i) {
    fn(this[i], i, this)
  }
}

function make_format_equiv(method, for_date, should_equal) {

  return new Function('test', 'assert', (function () {
    NAME;

    test(assert)
  }+'').replace('NAME', '"test of '+method+'"').slice('function () {'.length, -1))
    .bind(null, function(assert) {
      var fmt = new utils.DateFormat(for_date)
      assert.equal(fmt[method](), should_equal)
    })
}

exports.TestFormatter = platoon.unit({},
  function(assert) {
    "test that the formatter works as expected"
    var format    = [].slice.call("aAbcdDEfFgGhHiIjlLmMnNOPrsStTUuwWyYzZ")
      , datetime  = new Date
      , result    = utils.format(datetime, format.join('\n'))
      , formatter = new utils.DateFormat(datetime)

    result = result.split('\n')
    result.forEach(function(item, idx) {
      assert.equal(item, ''+formatter[format[idx]]())
    })
  }
);

exports.TestFormatMethods = platoon.unit({},

  // a.m. / p.m. format
    make_format_equiv('a', new Date(2010, 0, 1, 23, 0),   'p.m.')
  , make_format_equiv('a', new Date(2010, 0, 1, 1, 0),    'a.m.')

  // AM / PM format
  , make_format_equiv('A', new Date(2010, 0, 1, 1, 0),    'AM')
  , make_format_equiv('A', new Date(2010, 0, 1, 23, 0),   'PM')

  // time in 12-hour, omit minutes if 0
  , make_format_equiv('f', new Date(2010, 0, 1, 23, 0),   '11')
  , make_format_equiv('f', new Date(2010, 0, 1, 11, 0),   '11')
  , make_format_equiv('f', new Date(2010, 0, 1, 18, 30),  '6:30')
  , make_format_equiv('f', new Date(2010, 0, 1, 8, 30),   '8:30')

  // 12-hour format, no leading zeros
  , make_format_equiv('g', new Date(2010, 0, 1, 23, 0),   '11')
  , make_format_equiv('g', new Date(2010, 0, 1, 11, 0),   '11')
  , make_format_equiv('g', new Date(2010, 0, 1, 18, 30),  '6')
  , make_format_equiv('g', new Date(2010, 0, 1, 8, 30),   '8')

  // hour, 24 hour format, no leading zeros
  , make_format_equiv('G', new Date(2010, 0, 1, 18, 30),  '18')
  , make_format_equiv('G', new Date(2010, 0, 1, 8, 30),   '8')

  // hour, 12-hour format, leading zeros
  , make_format_equiv('h', new Date(2010, 0, 1, 18, 30),  '06')
  , make_format_equiv('h', new Date(2010, 0, 1, 8, 30),   '08')

  // hour, 24-hour format, leading zeros
  , make_format_equiv('H', new Date(2010, 0, 1, 18, 30),  '18')
  , make_format_equiv('H', new Date(2010, 0, 1, 8, 30),   '08')

  // minutes, leading zeros
  , make_format_equiv('i', new Date(2010, 0, 1, 18, 5),   '05')
  , make_format_equiv('i', new Date(2010, 0, 1, 8, 30),   '30')

  // time, 12 hours, minutes, 'a.m.', 'p.m.', sans minutes if zero, midnight or noon if appropriate
  , make_format_equiv('P', new Date(2010, 0, 1, 12, 0),   'noon')
  , make_format_equiv('P', new Date(2010, 0, 0, 0, 0),    'midnight')
  , make_format_equiv('P', new Date(2010, 0, 1, 8, 30),   '8:30 a.m.')
  , make_format_equiv('P', new Date(2010, 0, 1, 18, 3),   '6:03 p.m.')
  , make_format_equiv('P', new Date(2010, 0, 1, 18, 0),   '6 p.m.')

  // seconds, 00-59
  , make_format_equiv('s', new Date(2010, 0, 1, 18, 3, 0),  '00')
  , make_format_equiv('s', new Date(2010, 0, 1, 18, 3, 3),  '03')
  , make_format_equiv('s', new Date(2010, 0, 1, 18, 3, 30), '30')
  , make_format_equiv('s', new Date(2010, 0, 1, 18, 3, 59), '59')

  // milliseconds
  , make_format_equiv('u', new Date(2010, 0, 1, 18, 3, 59, 888), '888')
  , make_format_equiv('u', new Date(2010, 0, 1, 18, 3, 59, 5), '5')

  // month, 3 letters, lowercase
  , make_format_equiv('b', new Date(2010, 0, 1, 18, 3, 59, 888), 'jan')
  , make_format_equiv('b', new Date(2010, 1, 1, 18, 3, 59, 888), 'feb')
  , make_format_equiv('b', new Date(2010, 2, 1, 18, 3, 59, 888), 'mar')
  , make_format_equiv('b', new Date(2010, 3, 1, 18, 3, 59, 888), 'apr')
  , make_format_equiv('b', new Date(2010, 4, 1, 18, 3, 59, 888), 'may')
  , make_format_equiv('b', new Date(2010, 5, 1, 18, 3, 59, 888), 'jun')
  , make_format_equiv('b', new Date(2010, 6, 1, 18, 3, 59, 888), 'jul')
  , make_format_equiv('b', new Date(2010, 7, 1, 18, 3, 59, 888), 'aug')
  , make_format_equiv('b', new Date(2010, 8, 1, 18, 3, 59, 888), 'sep')
  , make_format_equiv('b', new Date(2010, 9, 1, 18, 3, 59, 888), 'oct')
  , make_format_equiv('b', new Date(2010,10, 1, 18, 3, 59, 888), 'nov')
  , make_format_equiv('b', new Date(2010,11, 1, 18, 3, 59, 888), 'dec')

  // iso format
  , make_format_equiv('c', new Date(2010,11, 1, 18, 3, 59, 888), (new Date(2010,11, 1, 18, 3, 59, 888)).toISOString())

  // day of month, 2 digits, leading zeros
  , make_format_equiv('d', new Date(2010,11, 2, 5, 3, 59, 888), '02')
  , make_format_equiv('d', new Date(2010,11,22, 5, 3, 59, 888), '22')

  // day of week, three letters, capfirst
  , make_format_equiv('D', new Date(2012, 0,15, 5, 3, 59, 888), 'Sun')
  , make_format_equiv('D', new Date(2012, 0,16, 5, 3, 59, 888), 'Mon')
  , make_format_equiv('D', new Date(2012, 0,17, 5, 3, 59, 888), 'Tue')
  , make_format_equiv('D', new Date(2012, 0,18, 5, 3, 59, 888), 'Wed')
  , make_format_equiv('D', new Date(2012, 0,19, 5, 3, 59, 888), 'Thu')
  , make_format_equiv('D', new Date(2012, 0,20, 5, 3, 59, 888), 'Fri')
  , make_format_equiv('D', new Date(2012, 0,21, 5, 3, 59, 888), 'Sat')

  // month, long, capfirst
  , make_format_equiv('F', new Date(2010, 0, 1, 18, 3, 59, 888), 'January')
  , make_format_equiv('F', new Date(2010, 1, 1, 18, 3, 59, 888), 'February')
  , make_format_equiv('F', new Date(2010, 2, 1, 18, 3, 59, 888), 'March')
  , make_format_equiv('F', new Date(2010, 3, 1, 18, 3, 59, 888), 'April')
  , make_format_equiv('F', new Date(2010, 4, 1, 18, 3, 59, 888), 'May')
  , make_format_equiv('F', new Date(2010, 5, 1, 18, 3, 59, 888), 'June')
  , make_format_equiv('F', new Date(2010, 6, 1, 18, 3, 59, 888), 'July')
  , make_format_equiv('F', new Date(2010, 7, 1, 18, 3, 59, 888), 'August')
  , make_format_equiv('F', new Date(2010, 8, 1, 18, 3, 59, 888), 'September')
  , make_format_equiv('F', new Date(2010, 9, 1, 18, 3, 59, 888), 'October')
  , make_format_equiv('F', new Date(2010,10, 1, 18, 3, 59, 888), 'November')
  , make_format_equiv('F', new Date(2010,11, 1, 18, 3, 59, 888), 'December')

  // 1 if DST, 0 if not
  , make_format_equiv('I', new Date(2010,1, 1, 18, 3, 59, 888), '0')
  , make_format_equiv('I', new Date(2010,8, 1, 18, 3, 59, 888), '1')

  // day of month, no leading zeros
  , make_format_equiv('j', new Date(2010,8, 5, 18, 3, 59, 888), '5')
  , make_format_equiv('j', new Date(2010,8,30, 18, 3, 59, 888), '30')

  // day of the week, textual, long
  , make_format_equiv('l', new Date(2012, 0,15, 5, 3, 59, 888), 'Sunday')
  , make_format_equiv('l', new Date(2012, 0,16, 5, 3, 59, 888), 'Monday')
  , make_format_equiv('l', new Date(2012, 0,17, 5, 3, 59, 888), 'Tuesday')
  , make_format_equiv('l', new Date(2012, 0,18, 5, 3, 59, 888), 'Wednesday')
  , make_format_equiv('l', new Date(2012, 0,19, 5, 3, 59, 888), 'Thursday')
  , make_format_equiv('l', new Date(2012, 0,20, 5, 3, 59, 888), 'Friday')
  , make_format_equiv('l', new Date(2012, 0,21, 5, 3, 59, 888), 'Saturday')

  // is leap year
  , make_format_equiv('L', new Date(2012, 0,20, 5, 3, 59, 888), 1)
  , make_format_equiv('L', new Date(2011, 0,21, 5, 3, 59, 888), 0)

  // month, digit, leading zeros
  , make_format_equiv('m', new Date(2010, 0, 1, 18, 3, 59, 888), '01')
  , make_format_equiv('m', new Date(2010, 1, 1, 18, 3, 59, 888), '02')
  , make_format_equiv('m', new Date(2010, 2, 1, 18, 3, 59, 888), '03')
  , make_format_equiv('m', new Date(2010, 3, 1, 18, 3, 59, 888), '04')
  , make_format_equiv('m', new Date(2010, 4, 1, 18, 3, 59, 888), '05')
  , make_format_equiv('m', new Date(2010, 5, 1, 18, 3, 59, 888), '06')
  , make_format_equiv('m', new Date(2010, 6, 1, 18, 3, 59, 888), '07')
  , make_format_equiv('m', new Date(2010, 7, 1, 18, 3, 59, 888), '08')
  , make_format_equiv('m', new Date(2010, 8, 1, 18, 3, 59, 888), '09')
  , make_format_equiv('m', new Date(2010, 9, 1, 18, 3, 59, 888), '10')
  , make_format_equiv('m', new Date(2010,10, 1, 18, 3, 59, 888), '11')
  , make_format_equiv('m', new Date(2010,11, 1, 18, 3, 59, 888), '12')

  // month, 3 letters, capfirst
  , make_format_equiv('M', new Date(2010, 0, 1, 18, 3, 59, 888), 'Jan')
  , make_format_equiv('M', new Date(2010, 1, 1, 18, 3, 59, 888), 'Feb')
  , make_format_equiv('M', new Date(2010, 2, 1, 18, 3, 59, 888), 'Mar')
  , make_format_equiv('M', new Date(2010, 3, 1, 18, 3, 59, 888), 'Apr')
  , make_format_equiv('M', new Date(2010, 4, 1, 18, 3, 59, 888), 'May')
  , make_format_equiv('M', new Date(2010, 5, 1, 18, 3, 59, 888), 'Jun')
  , make_format_equiv('M', new Date(2010, 6, 1, 18, 3, 59, 888), 'Jul')
  , make_format_equiv('M', new Date(2010, 7, 1, 18, 3, 59, 888), 'Aug')
  , make_format_equiv('M', new Date(2010, 8, 1, 18, 3, 59, 888), 'Sep')
  , make_format_equiv('M', new Date(2010, 9, 1, 18, 3, 59, 888), 'Oct')
  , make_format_equiv('M', new Date(2010,10, 1, 18, 3, 59, 888), 'Nov')
  , make_format_equiv('M', new Date(2010,11, 1, 18, 3, 59, 888), 'Dec')

  // month, digit, no leading zeros
  , make_format_equiv('n', new Date(2010, 0, 1, 18, 3, 59, 888), '1')
  , make_format_equiv('n', new Date(2010, 1, 1, 18, 3, 59, 888), '2')
  , make_format_equiv('n', new Date(2010, 2, 1, 18, 3, 59, 888), '3')
  , make_format_equiv('n', new Date(2010, 3, 1, 18, 3, 59, 888), '4')
  , make_format_equiv('n', new Date(2010, 4, 1, 18, 3, 59, 888), '5')
  , make_format_equiv('n', new Date(2010, 5, 1, 18, 3, 59, 888), '6')
  , make_format_equiv('n', new Date(2010, 6, 1, 18, 3, 59, 888), '7')
  , make_format_equiv('n', new Date(2010, 7, 1, 18, 3, 59, 888), '8')
  , make_format_equiv('n', new Date(2010, 8, 1, 18, 3, 59, 888), '9')
  , make_format_equiv('n', new Date(2010, 9, 1, 18, 3, 59, 888), '10')
  , make_format_equiv('n', new Date(2010,10, 1, 18, 3, 59, 888), '11')
  , make_format_equiv('n', new Date(2010,11, 1, 18, 3, 59, 888), '12')

  // month, AP format.
  , make_format_equiv('N', new Date(2010, 0, 1, 18, 3, 59, 888), 'Jan.')
  , make_format_equiv('N', new Date(2010, 1, 1, 18, 3, 59, 888), 'Feb.')
  , make_format_equiv('N', new Date(2010, 2, 1, 18, 3, 59, 888), 'March')
  , make_format_equiv('N', new Date(2010, 3, 1, 18, 3, 59, 888), 'April')
  , make_format_equiv('N', new Date(2010, 4, 1, 18, 3, 59, 888), 'May')
  , make_format_equiv('N', new Date(2010, 5, 1, 18, 3, 59, 888), 'June')
  , make_format_equiv('N', new Date(2010, 6, 1, 18, 3, 59, 888), 'July')
  , make_format_equiv('N', new Date(2010, 7, 1, 18, 3, 59, 888), 'Aug.')
  , make_format_equiv('N', new Date(2010, 8, 1, 18, 3, 59, 888), 'Sept.')
  , make_format_equiv('N', new Date(2010, 9, 1, 18, 3, 59, 888), 'Oct.')
  , make_format_equiv('N', new Date(2010,10, 1, 18, 3, 59, 888), 'Nov.')
  , make_format_equiv('N', new Date(2010,11, 1, 18, 3, 59, 888), 'Dec.')

  // difference to greenwich time in hours (+0200)
  , make_format_equiv('O', {getTimezoneOffset:Function('return 0')}, '+0000')
  , make_format_equiv('O', {getTimezoneOffset:Function('return -10')}, '+0010')
  , make_format_equiv('O', {getTimezoneOffset:Function('return 10')}, '-0010')

  // D, j M Y H:i:s O
  , make_format_equiv('r', new Date(2010,11, 1, 18, 3, 59, 888), utils.format(new Date(2010,11, 1, 18, 3, 59, 888), 'D, j M Y H:i:s O'))

  // ordinal suffix for day of month, 2 chars, st, nd, rd, th
  , make_format_equiv('S', new Date(2010,11, 1, 18, 3, 59, 888), 'st')
  , make_format_equiv('S', new Date(2010,11, 2, 18, 3, 59, 888), 'nd')
  , make_format_equiv('S', new Date(2010,11, 3, 18, 3, 59, 888), 'rd')
  , make_format_equiv('S', new Date(2010,11, 4, 18, 3, 59, 888), 'th')
  , make_format_equiv('S', new Date(2010,11,11, 18, 3, 59, 888), 'th')
  , make_format_equiv('S', new Date(2010,11,21, 18, 3, 59, 888), 'st')

  // number of days in a given month
  , make_format_equiv('t', new Date(2010, 0, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010, 1, 1, 18, 3, 59, 888), 28)
  , make_format_equiv('t', new Date(2012, 1, 1, 18, 3, 59, 888), 29)  // <-- leap year!
  , make_format_equiv('t', new Date(2010, 2, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010, 3, 1, 18, 3, 59, 888), 30)
  , make_format_equiv('t', new Date(2010, 4, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010, 5, 1, 18, 3, 59, 888), 30)
  , make_format_equiv('t', new Date(2010, 6, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010, 7, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010, 8, 1, 18, 3, 59, 888), 30)
  , make_format_equiv('t', new Date(2010, 9, 1, 18, 3, 59, 888), 31)
  , make_format_equiv('t', new Date(2010,10, 1, 18, 3, 59, 888), 30)
  , make_format_equiv('t', new Date(2010,11, 1, 18, 3, 59, 888), 31)

  // tzinfo
  , make_format_equiv('T', new Date(2010,11, 1, 18, 3, 59, 888), Date.prototype.tzinfo ? new Date(2010,11, 1, 18, 3, 59, 888).tzinfo().abbr || '???' : '???')

  // seconds since the unix epoch
  , make_format_equiv('U', new Date(2010,11, 1, 18, 3, 59, 888), ~~(new Date(2010,11, 1, 18, 3, 59, 888)/1000))

  // day of week, number, awesome
  , make_format_equiv('w', new Date(2012, 0,15, 5, 3, 59, 888), 0)
  , make_format_equiv('w', new Date(2012, 0,16, 5, 3, 59, 888), 1)
  , make_format_equiv('w', new Date(2012, 0,17, 5, 3, 59, 888), 2)
  , make_format_equiv('w', new Date(2012, 0,18, 5, 3, 59, 888), 3)
  , make_format_equiv('w', new Date(2012, 0,19, 5, 3, 59, 888), 4)
  , make_format_equiv('w', new Date(2012, 0,20, 5, 3, 59, 888), 5)
  , make_format_equiv('w', new Date(2012, 0,21, 5, 3, 59, 888), 6)

  // ISO-8601 week number of year
  , function(assert) {
      var first_day = +new Date(2012, 0, 1, 12, 30)
        , week = 1000 * 60 * 60 * 24 * 7


      for(var i = 0; i < 52; ++i) {
        assert.equal(utils.format(new Date(first_day + week * i), 'W'), i+1)
      }
    }


  // year, 2 digits
  , make_format_equiv('y', new Date(1986, 0, 3, 5, 3, 59, 888), 86)
  , make_format_equiv('y', new Date(2000, 0, 3, 5, 3, 59, 888), '00')
  , make_format_equiv('y', new Date(2012, 0, 3, 5, 3, 59, 888), 12)

  // year, 4 digits
  , make_format_equiv('Y', new Date(1986, 0, 3, 5, 3, 59, 888), 1986)
  , make_format_equiv('Y', new Date(2000, 0, 3, 5, 3, 59, 888), 2000)
  , make_format_equiv('Y', new Date(2012, 0, 3, 5, 3, 59, 888), 2012)

  // day of year, 0-365
  , function(assert) {
    var year = +new Date(new Date().getFullYear(), 0, 1, 0, 0)
      , day = 1000 * 60 * 60 * 24

    for(var i = 0; i < 365; ++i) { 
      assert.equal(utils.format(new Date(year + (day * i) + 1000), 'z'), i + 1)
    }
  }

  // timezone offset in seconds (-43200 to 43200)
  , make_format_equiv('Z', new Date(2012, 0, 3, 5, 3, 59, 888), new Date(2012, 0, 3, 5, 3, 59, 888).getTimezoneOffset() * -60)
)

  })(Function(), testrunner.make("./tests/utils.js"));(function (require, exports) {
    ;if(typeof window === 'undefined') {
  var plate = require('../index')
    , utils = require('../lib/utils')
    , platoon = require('platoon')
} else {
  var plate = window.plate
    , platoon = window.platoon
    , utils = plate.utils
}

exports.TestAddFilter = platoon.unit({},
    function(assert) {
        "Test that the add filter works as expected";
        var tpl = new plate.Template("{{ test|add:3 }}"),
            rnd = ~~(Math.random()*10);

        tpl.render({'test':rnd}, assert.async(function(err, data) {
            assert.equal((rnd+3), parseInt(data, 10));
        }));
    }
);

exports.TestAddSlashesFilter = platoon.unit({},
    function(assert) {
        "Test that the addslashes filter works as expected";
        var tpl = new plate.Template("{{ test|addslashes }}"),
            ctxt = {},
            inp = [],
            num = 1 + ~~(Math.random()*10);

        for(var i = 0; inp.push("'") < num; ++i) {};

        inp = inp.join("asdf");
        ctxt.test = inp;

        tpl.render(ctxt, assert.async(function(err, data) {
            assert.equal(data.split('\\').length, num+1);
        }));
    }
);

exports.TestCapFirstFilter = platoon.unit({},
    function(assert) {
        "Test that the capfirst filter works as expected";
        var corpus = ['a', 'fluffy bunny', '99 times', 'lol', '', 3.2, {'toString':function(){return 'lol';}}],
            template = new plate.Template("{{ test|capfirst }}"),
            emitter = function(item) {
                var ctxt = { 'test':item };
                template.render(ctxt, assert.async(function(err, data) {
                    assert.equal(data.charAt(0), item.toString().charAt(0).toUpperCase());
                }));
            };
        for(var i = 0; i < corpus.length; ++i) {
            emitter(corpus[i]);
        }
    }
);

exports.TestCenterFilter = platoon.unit({},
    function(assert) {
        "Test that the center filter works as expected.";
        var corpus = ['a', 'bunny', 'rode', 'firmly', 'through', 'the', 'wood'],
            template = new plate.Template("{{ test|center:centernum }}"),
            emitter = function(item, len) {
                template.render({'test':item, 'centernum':len}, assert.async(function(err, data) {
                    if(item.length >= len) {
                        assert.equal(data.length, data.length);
                    } else {
                        assert.equal(data.length, len);
                        var parts = data.split(item),
                            wlen = len - item.length,
                            strong_side = item.length % 2 == 0 ? 0 : 1,
                            testlen = Math.floor(wlen/2.0),
                            uneven = (wlen/2.0) - Math.floor(wlen/2.0) > 0.0;

                        if(uneven) {
                            assert.equal(parts[strong_side].length, testlen+1);
                            assert.equal(parts[0+!strong_side].length, testlen);
                        } else {
                            assert.equal(parts[strong_side].length, testlen);
                            assert.equal(parts[0+strong_side].length, testlen);
                        }
                    }
                }));
            },
            item = null;
        while(corpus.length > 0) {
            item = corpus.shift();
            emitter(item, ~~(Math.random() * 10) + 2);
        }
    }
);

exports.TestCutFilter = platoon.unit({},
    function(assert) {
        "Test that the cut filter works as expected";
        var corpus = 'abcdefghijklmnopqrstuvwxyz',
            template = new plate.Template("{{ test|cut:val }}"),
            rand = function() {
                return String.fromCharCode(~~(Math.random() * ('z'.charCodeAt(0) - 'a'.charCodeAt(0))) + 'a'.charCodeAt(0));
            },
            emitter = function(item) {
                template.render({'test':corpus, 'val':item}, assert.async(function(err, data) {
                    assert.equal(data.indexOf(item), -1);
                }));
            };
        var len = ~~(Math.random() * 10);
        while(len-- > 0) emitter(rand());
    }
);

exports.TestDateFilter = platoon.unit({},
    function(assert) {
        "Test that the date filter defaults to 'N j, Y'";

        var tpl = new plate.Template("{{ test|date }}")
          , dt
          , now = utils.format(dt = new Date, "N j, Y")

        tpl.render({test:dt}, assert.async(function(err, data) {
            assert.equal(data, now)
        }))
    },
    function(assert) {
        "Test that the date filter accepts a format arg";

        var tpl = new plate.Template("{{ test|date:'jS o\\f F' }}")
          , dt
          , now = utils.format(dt = new Date, "jS o\\f F")

        tpl.render({test:dt}, assert.async(function(err, data) {
            assert.equal(data, now)
        }))
    },
    function(assert) {
        "Test that the date filter accepts non-date arguments";

        var tpl = new plate.Template("{{ test|date:'jS o\\f F' }}")
          , dt
          , now = utils.format(dt = new Date, "jS o\\f F")

        tpl.render({test:+dt}, assert.async(function(err, data) {
            assert.equal(data, now)
        }))

        tpl.render({test:''+dt}, assert.async(function(err, data) {
            assert.equal(data, now)
        }))
    }
)

exports.TestDefaultFilter = platoon.unit({},
    function(assert) {
        "Test that the default filter works as expected";
        var random = ~~(Math.random() * 10),
            template = new plate.Template("{{ test|default:default }}"),
            corpus = ['truthy', 0, null, false, undefined, NaN, {'toString':function(){return'lol';}}],
            emitter = function(item) {
                template.render({'test':item, 'default':random}, assert.async(function(err, data) {
                    if(item) assert.equal(data, item.toString());
                    else     assert.equal(data, random);
                }));
            }
        while(corpus.length) {
            emitter(corpus.shift());
        }
    }
);

exports.TestDictSortFilter = platoon.unit({},
    function(assert) {
        "Test that the dictsort filter works as expected";
        var F = function() {
                var self = this;
                this.value = ~~(Math.random() * 10);
                this.toString = function() {
                    return self.value;
                };
            },
            len = ~~(Math.random() * 10) + 1,
            arr = [],
            sorted = null,
            template = new plate.Template("{% for i in items|dictsort:\"value\" %}{{ i }}\n{% endfor %}");
        while(len--) {
            arr.push(new F());
        }
        sorted = arr.slice().sort(function(x, y) {
            if(x.value < y.value) return -1;
            if(x.value > y.value) return 1;
            return 0;
        });
        template.render({'items':arr}, assert.async(function(err, data) {
            var split = data.split('\n').slice(0,-1);
            while(split.length > 0) {
                assert.equal(split.shift(), sorted.shift().toString());
            }
        }));
    },
    function(assert) {
        "Test that the dictsortreversed filter works as expected";
        var F = function() {
                var self = this;
                this.value = ~~(Math.random() * 10);
                this.toString = function() {
                    return self.value;
                };
            },
            len = ~~(Math.random() * 10) + 1,
            arr = [],
            sorted = null,
            template = new plate.Template("{% for i in items|dictsortreversed:\"value\" %}{{ i }}\n{% endfor %}");
        while(len--) {
            arr.push(new F());
        }
        sorted = arr.slice().sort(function(x, y) {
            if(x.value < y.value) return -1;
            if(x.value > y.value) return 1;
            return 0;
        }).reverse();
        template.render({'items':arr}, assert.async(function(err, data) {
            var split = data.split('\n').slice(0,-1);
            while(split.length > 0) {
                assert.equal(split.shift(), sorted.shift().toString());
            }
        }));
    }
);

exports.TestOfDivisibleByFilter = platoon.unit({},
    function(assert) {
        "Test that the divisibleby filter works as expected";
        var pairs = (function(num) {
            var accum = [];
            for(;accum.length < num; accum.push([~~(Math.random()*10), ~~(Math.random()*10)]));
            return accum;
        })(~~(Math.random() * 10) + 2),
        template = new plate.Template("{% for x,y in pairs %}{% if x|divisibleby:y %}y{% else %}n{% endif %}\n{% endfor %}");
        template.render({pairs:pairs}, assert.async(function(err, data) {
            var bits = data.split('\n').slice(0, -1);
            for(var i = 0, len = bits.length; i < len; ++i) {
                assert.equal(pairs[i][0] % pairs[i][1] == 0 ? 'y' : 'n', bits[i]);
            }
        }));
    }
);

exports.TestOfFilesizeFormatFilter = platoon.unit({},
    function(assert) {
        "Test that the filesizeformat filter works as expected";
        var items = [],
            template = new plate.Template("{{ i|filesizeformat }}");

        for(var i = 2, len = (1024*1024*1024*1024); i < len; i = Math.pow(i, 2)) {
            (function(item) {
                template.render({i:item}, assert.async(function(err, data) {
                    var words = data.split(/\s+/);
                    if(item < 1024) {
                        assert.equal(words.slice(-1)[0], 'bytes');
                    } else if(item < (1024*1024)) {
                        assert.equal(words.slice(-1)[0], 'KB');
                    } else if(item < (1024*1024*1024)) {
                        assert.equal(words.slice(-1)[0], 'MB');
                    } else {
                        assert.equal(words.slice(-1)[0], 'GB');
                    }
                }));
            })(i);
        }
    }
);

exports.TestOfFirstFilter = platoon.unit({},
    function(assert) {
        "Test that the first filter works as expected";
        var items = (function(len) {
                var accum = [];
                while(accum.length < len) {
                    accum.push(~~(Math.random()*10));
                }
                return accum;
            })(~~(Math.random()*10)+1),
            template = new plate.Template("{{ items|first }}");
        template.render({items:items}, assert.async(function(err, data) {
            assert.equal(data, items[0].toString());
        }));
    }
);

exports.TestOfFloatFormatFilter = platoon.unit({},
    function(assert) {
        "Test that the floatformat filter works as expected";
        var tpl = new plate.Template(
                "{% for x,y in values %}{{ forloop.counter0 }}:{{ x|floatformat:y }}\n{% endfor %}"
            ),
            context = {
                'values':[]
            };

        while(context.values.length < 10) {
            context.values.push([
                (Math.random() * 10),
                (~~(Math.random()*10)-5)
            ]);
        }

        tpl.render(context, assert.async(function(err, data) {
            var lines = data.split('\n').slice(0, -1),
                line_split,
                idx,
                val,
                val_split,
                decimal;
            while(lines.length) {
                line_split = lines.shift().split(':');
                idx = line_split[0];
                val = line_split[1];
                val_split = val.split('.');
                decimal = val_split.length > 1 ? val_split[1] : '';


                if(context.values[idx][1] < 1) {
                    assert.ok(decimal.length <= parseInt(Math.abs(context.values[idx][1])));
                } else {
                    assert.ok(decimal.length == parseInt(context.values[idx][1]));
                }
            }
        }));
    }
);

exports.TestOfGetDigit = platoon.unit({},
    function(assert) {
      "Test that the get_digit filter works as expected.";
      var tpl = new plate.Template(
        "{% for x in digit|make_list %}{{ digit|get_digit:forloop.counter }}\n{% endfor %}"
      ),
      context = {
        'digit':~~(Math.random()*1000)
      };
      tpl.render(context, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1),
            num = context.digit.toString();

        assert.equal(bits.reverse().join(''), num);
      }));
    },
    function(assert) {
      "Test that get_digit returns the original input when given a bad digit";
      var tpl = new plate.Template(
          "{{ digit|get_digit:badfood }}"
        ),
        context = {
          'digit':~~(Math.random()*1000),
          'badfood':'asdf'
        };

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, context.digit.toString());
      }));
    }
);

exports.TestOfJoin = platoon.unit({},
    function(assert) {
      "Test that the join filter works as expected.";
      var tpl = new plate.Template(
          "{{ a_list|join:value }}"
        ),
        context = {
          a_list:[1,2,3,4,5],
          value:~~(Math.random()*100)
        };
      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, context.a_list.join(context.value));
      }));
    }
);

exports.TestOfLast = platoon.unit({},
    function(assert) {
      "Test that last grabs the last element of a list.";
      var tpl = new plate.Template(
        "{{ a_list|last }}"
      ),
      context = {
        a_list:[1,2,3,3,4,556,6,76,7,5,4,6].sort(function(lhs, rhs) {
          return Math.random() > 0.5;
        })
      };
      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, context.a_list[context.a_list.length-1]);
      }));
    }
);

exports.TestOfLength = platoon.unit({},
    function(assert) {
      "Test that length works with simple arrays.";
      var tpl = new plate.Template(
        "{{ a_list|length }}"
      ),
      random_array = function() {
        var len = 1+~~(Math.random()*100),
            out = [];
        while(out.length < len) out.push(Math.random());
        return out;
      },
      context = {
        a_list:random_array()
      };
      tpl.render(context, assert.async(function(err, data) {
        assert.equal(context.a_list.length, data);
      }));
    },
    function(assert) {
      "Test that length works with complex objects.";
      var randLen = ~~(Math.random()*10) + 1,
          lenFn = function(callback) {
            setTimeout(assert.async(function() {
              callback(null, randLen);
            }), 1);
          },
          tpl = new plate.Template(
              "{{ a_list|length }}"
          ),
          context = {
            a_list:{length:lenFn}
          };

      tpl.render(context, assert.async(function(err, data) {
          assert.equal(data, randLen);
      }));
    }
);

exports.TestOfLengthIs = platoon.unit({},
    function(assert) {
      "Test that length_is works with simple arrays.";
      var tpl = new plate.Template(
        "{{ a_list|length_is:a_list.length }}\n{{ a_list|length_is:0 }}"
      ),
      random_array = function() {
        var len = 1+~~(Math.random()*100),
            out = [];
        while(out.length < len) out.push(Math.random());
        return out;
      },
      context = {
        a_list:random_array()
      };
      tpl.render(context, assert.async(function(err, data) {
        assert.equal('true\nfalse', data);
      }));
    },
    function(assert) {
      "Test that length_is works with complex objects.";
      var randLen = ~~(Math.random()*10) + 1,
          lenFn = function(callback) {
            setTimeout(assert.async(function() {
              callback(null, randLen);
            }), 1);
          },
          tpl = new plate.Template(
              "{% with a_list.length as len %}{{ a_list|length_is:len }}\n{{ a_list|length_is:0 }}{% endwith %}"
          ),
          context = {
            a_list:{length:lenFn}
          };

      tpl.render(context, assert.async(function(err, data) {
          assert.equal(data, "true\nfalse");
      }));
    }
);

exports.TestOfLineBreaks = platoon.unit({},
    function(assert) {
      "Test that linebreaks wraps all double-spaced elements in <p> tags.";
      var text = "Hi there\n\nI am new to world\n\nEnjoying time very much.",
          tpl = new plate.Template(
            "{{ text|linebreaks }}"
          ),
          context = { text: text };

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, "<p>Hi there</p><p>I am new to world</p><p>Enjoying time very much.</p>");
      }));
    },
    function(assert) {
      "Test that linebreaks creates <br /> tags for all single newline characters.";
      var text = "Hi there\nI am new to world\nEnjoying time very much.",
          tpl = new plate.Template(
            "{{ text|linebreaks }}"
          ),
          context = { text: text };

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, "<p>Hi there<br />I am new to world<br />Enjoying time very much.</p>");
      }));
    }
);

exports.TestOfLineBreaksBr = platoon.unit({},
    function(assert) {
      "Test that linebreaksbr converts all newlines to br elements";
      var text = "Hi there\n\nI am new\n to world\n\nEnjoying time very much.",
          tpl = new plate.Template(
            "{{ text|linebreaksbr }}"
          ),
          context = { text: text };

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, text.replace(/\n/g, '<br />'));
      }));
    }
);

exports.TestOfLineNumbers = platoon.unit({},
    function(assert) {
      "Test that linenumbers prepends line numbers to each line of input text.";
      var text = "Yes\nI\nLike\nJavascript\nIs\nVery\nGood",
          tpl = new plate.Template(
            "{{ text|linenumbers }}"
          ),
          context = { text: text };

      tpl.render(context, assert.async(function(err, data) {
        var expected = text.split('\n');
        for(var i = 0, len = expected.length; i < len; ++i) {
          expected[i] = (i+1)+'. '+expected[i];
        }
        expected = expected.join('\n');
        assert.equal(data, expected);
      }));
    }
);

exports.TestOfLJust = platoon.unit({},
    function(assert) {
      "Test that ljust left justifies as expected.";
      var tpl = new plate.Template(
        "{% for i in range %}{{ str|ljust:i }}\n{% endfor %}"
      ),
      makeRange = function() {
        var out = [], len = ~~(Math.random()*20) + 1;
        while(out.length < len) { out.push(out.length+1); }
        return out;
      },
      context = {
        'str':'hi',
        'range':makeRange()
      };

      tpl.render(context, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1);
        while(bits.length) {
          var idx = context.range.length - bits.length
              bit = bits.shift();

          if(bit.length > context.str.length) {
            assert.equal(bit.length, context.range[idx]);
            assert.ok((/\s+$/g).test(bit));
          } else {
            assert.strictEqual(bit.length, context.str.length);
          }
        }
      }));
    }
);

exports.TestOfLower = platoon.unit({},
    function(assert) {
      "Test that lower works.";
      var tpl = new plate.Template(
        "{% for word in words %}{{ word|lower }}{% endfor %}"
      );
      tpl.render({words:['Asdf', '1ST', 'YEAHHHH']}, assert.async(function(err, data) {
        assert.fail((/[A-Z]+/g).test(data));
      }));
    }
);

exports.TestOfMakeList = platoon.unit({},
  function(assert) {
    "Test that make_list just passes through arrays.";
    var tpl = new plate.Template(
      '{% for i in item|make_list %}{{ i }}{% if not forloop.last %}\n{% endif %}{% endfor %}'
    ),
    item = [1,2,3,4,5];
    tpl.render({'item':item}, assert.async(function(err, data) {
      var bits = data.split('\n');
      assert.equal(bits.length, item.length);
      while(bits.length) {
        assert.equal(bits.pop(), item.pop());
      };
    }));
  },
  function(assert) {
    "Test that make_list works with strings.";
    var tpl = new plate.Template(
      '{% for i in item|make_list %}{{ i }}{% if not forloop.last %}\n{% endif %}{% endfor %}'
    ),
    item = "random"+Math.random();
    tpl.render({'item':item}, assert.async(function(err, data) {
      var bits = data.split('\n');
      item = item.toString().split('');
      assert.equal(bits.length, item.length);
      while(bits.length) {
        assert.equal(bits.pop(), item.pop());
      };
    }));
  },
  function(assert) {
    "Test that make_list works with numbers.";
    var tpl = new plate.Template(
      '{% for i in item|make_list %}{{ i }}{% if not forloop.last %}\n{% endif %}{% endfor %}'
    ),
    item = ~~(100 * Math.random());
    tpl.render({'item':item}, assert.async(function(err, data) {
      var bits = data.split('\n');
      item = item.toString().split('');
      assert.equal(bits.length, item.length);
      while(bits.length) {
        assert.equal(bits.pop(), item.pop());
      };
    }));
  }
);

exports.TestOfPhone2Numeric = platoon.unit({},
    function(assert) {
      "Test that phone2numeric works as expected.";
      var phone = '1-800-4GO-OGLE',
          expected = '1-800-446-6453',
          tpl = new plate.Template(
              "{{ item|phone2numeric }}"
          );
      tpl.render({'item':phone}, assert.async(function(err, data) {
        assert.equal(data, expected);
      }));

    }
);

exports.TestOfPluralize = platoon.unit({},
    function(assert) {
      "Assert that pluralize coerces single argument to plural case.";
      var values = [1,3],
          tpl = new plate.Template(
            '{% for i in items %}{{ i|pluralize:"s" }}:{% endfor %}'
          );
      tpl.render({items:values}, assert.async(function(err, data) {
        assert.equal(data, ':s:');
      }));
    },
    function(assert) {
      "Assert that pluralize coerces two arguments to singular, plural.";
      var values = [1,3],
          tpl = new plate.Template(
            '{% for i in items %}{{ i|pluralize:"y,s" }}:{% endfor %}'
          );
      tpl.render({items:values}, assert.async(function(err, data) {
        assert.equal(data, 'y:s:');
      }));
    }
);

exports.TestOfRandom = platoon.unit({},
    function(assert) {
      "Assert that random pulls an item out of an array randomly.";
      var arr = [1,2,3,4,5,6,7,8,9,10],
          tpl = new plate.Template(
            '{% for i in list %}{{ list|random }}\n{% endfor %}'
          );

      tpl.render({list:arr}, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1);
        while(bits.length) {
          for(var i = 0, len = arr.length, item = bits.pop(), found = false; i < len && !found; ++i) {
            found = arr[i] == item;
          }
          assert.ok(found);
        }
      }));
    }
);

exports.TestOfRJust = platoon.unit({},
    function(assert) {
      "Test that rjust right justifies as expected.";
      var tpl = new plate.Template(
        "{% for i in range %}{{ str|rjust:i }}\n{% endfor %}"
      ),
      makeRange = function() {
        var out = [], len = ~~(Math.random()*20) + 1;
        while(out.length < len) { out.push(out.length+1); }
        return out;
      },
      context = {
        'str':'hi',
        'range':makeRange()
      };

      tpl.render(context, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1);
        while(bits.length) {
          var idx = context.range.length - bits.length
              bit = bits.shift();

          assert.ok(bit.length === context.str.length || bit.length === context.range[idx]);
          if(bit.length > context.str.length) {
            assert.ok((/^\s+/g).test(bit));
          }
        }
      }));
    }
);

exports.TestOfUpper = platoon.unit({},
    function(assert) {
      "Test that upper works.";
      var tpl = new plate.Template(
        "{% for word in words %}{{ word|upper }}{% endfor %}"
      );
      tpl.render({words:['Asdf', '1ST', 'YEAHHHH']}, assert.async(function(err, data) {
        assert.fail((/[a-z]+/g).test(data));
      }));
    }
);

exports.TestOfSafeFilter = platoon.unit({},
    function(assert) {
      "Test that HTML characters are escaped by default";

      var tpl = new plate.Template('{{ value }}')

      tpl.render({'value':'<>"\'&'}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, '&lt;&gt;&quot;&#39;&amp;')
      }))
    },
    function(assert) {
      "Test that HTML characters may be marked 'safe'";

      var tpl = new plate.Template('{{ value|safe }}')
        , x = '<>"\'&'
      tpl.render({'value':x}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, x)
      }))
    }
)

exports.TestOfEscapeFilter = platoon.unit({},
    function(assert) {
      "Test that escape automatically escapes the input";

      var tpl = new plate.Template('{{ value|escape }}')
        , x   = '&'

      tpl.render({value:x}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, '&amp;')
      }))
    },
    function(assert) {
      "Test that escape does not double-escape the input";

      var tpl = new plate.Template('{{ value|escape|escape }}')
        , x   = '&'

      tpl.render({value:x}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, '&amp;')
      }))
    },
    function(assert) {
      "Test that escape respects 'safe'";

      var tpl = new plate.Template('{{ value|safe|escape }}')
        , x   = '&'

      tpl.render({value:x}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, '&')
      }))
    },
    function(assert) {
      "Test that force_escape does not respect 'safe'";

      var tpl = new plate.Template('{{ value|safe|force_escape }}')
        , x   = '&'

      tpl.render({value:x}, assert.async(function(err, data) {
        assert.ok(!err)

        assert.equal(data, '&amp;')
      }))
    }
)

exports.TestOfSlice = platoon.unit({},
    function(assert) {
      "Test that slice works with :N";
      var items = [1,2,3,4],
          rand = ~~(items.length * Math.random()),
          tpl = new plate.Template(
            "{% for i in items|slice:rand %}{{ i }}:{% endfor %}"
          );

      tpl.render({items:items, rand:':'+rand}, assert.async(function(err, data) {
        var bits = data.split(':').slice(0, -1),
            expected = items.slice(0, rand);

        assert.equal(bits.length, expected.length);
        for(var i = 0, len = bits.length; i < len; ++i) {
          assert.equal(bits[i], expected[i]);
        }
      }));
    },
    function(assert) {
      "Test that slice works with N:";
      var items = [1,2,3,4],
          rand = ~~(items.length * Math.random()),
          tpl = new plate.Template(
            "{% for i in items|slice:rand %}{{ i }}:{% endfor %}"
          );

      tpl.render({items:items, rand:rand+':'}, assert.async(function(err, data) {
        var bits = data.split(':').slice(0, -1),
            expected = items.slice(rand);

        assert.equal(bits.length, expected.length);
        for(var i = 0, len = bits.length; i < len; ++i) {
          assert.equal(bits[i], expected[i]);
        }
      }));
    }
);

exports.TestOfSlugify = platoon.unit({},
    function(assert) {
      "Test that slugify removes unicode, turns spaces into dashes, lowercases everything.";
      var makeRandomString = function() {
        var len = ~~(Math.random()*1000),
            out = [];
        while(out.length < len) out.push(String.fromCharCode(~~(Math.random()*256)));
        return out.join('');
      },
      tpl = new plate.Template('{{ item|slugify }}'),
      context = {item:makeRandomString()};

      tpl.render(context, assert.async(function(err, data) {
        assert.fail((/[^a-z\-0-9_]+/g).test(data));
      }));
    }
);

exports.TestOfTimesince = platoon.unit({},
  function(assert) {
    "Test that timesince works as expected.";
    var times = [
          ['3 years', Date.now() - 31557600000 * 3]
        , ['1 month', Date.now() - 2592000000 * 1]
        , ['2 days', Date.now() - 86400000 * 2]
        , ['23 hours', Date.now() - 3600000 * 23]
        , ['30 minutes', Date.now() - 60000 * 30]
      ]
    , tpl = new plate.Template("{% for expected, time in times %}{{ time|timesince }}\n{% endfor %}")

    tpl.render({times:times}, assert.async(function(err, data) {
      assert.ok(!err)

      data = data.split('\n').slice(0, -1)
      for(var i = 0; i < data.length; ++i) {
        assert.equal(data[i], times[i][0])
      }
    }))
  },
  function(assert) {
    "Test that timesince may accept an input.";

    var fake_now = +new Date() + ~~(Math.random() * 10000)
    var times = [
          ['3 years',     fake_now - 31557600000 * 3]
        , ['1 month',     fake_now - 2592000000 * 1]
        , ['2 days',      fake_now - 86400000 * 2]
        , ['23 hours',    fake_now - 3600000 * 23]
        , ['30 minutes',  fake_now - 60000 * 30]
      ]
    , tpl = new plate.Template("{% for expected, time in times %}{{ time|timesince:n }}\n{% endfor %}")

    tpl.render({times:times, n:fake_now}, assert.async(function(err, data) {
      assert.ok(!err)

      data = data.split('\n').slice(0, -1)
      for(var i = 0; i < data.length; ++i) {
        assert.equal(data[i], times[i][0])
      }
    }))
  },
  function(assert) {
    "Test that timesince displays the largest and second largest bit of multiple time values.";
    var times = [
          ['3 years, 2 days',   Date.now() - (31557600000 * 3 + 86400000 * 2 + 60000)]
        , ['1 month, 23 hours',           Date.now() - (2592000000 + 3600000 * 23)]
        , ['1 year, 10 days', Date.now() - (31557600000 + 10 * 86400000 + 20 * 60000)]
      ]
    , tpl = new plate.Template("{% for expected, time in times %}{{ time|timesince }}\n{% endfor %}")

    tpl.render({times:times}, assert.async(function(err, data) {
      assert.ok(!err)

      data = data.split('\n').slice(0, -1)
      for(var i = 0; i < data.length; ++i) {
        assert.equal(data[i], times[i][0])
      }
    }))
  },
  function(assert) {
    "Test that timesince displays '0 minutes' when time is in future, or when time is < 60 seconds away";
    var t = new Date()
      , n = t + 1000
      , tpl = new plate.Template("{{ t|timesince:n }}")

    tpl.render({t:t, n:n}, assert.async(function(err, data) {
      assert.equal(data, '0 minutes')
    }))

    tpl.render({t:t, n:t}, assert.async(function(err, data) {
      assert.equal(data, '0 minutes')
    })) 
  }
)

exports.TestOfTitle = platoon.unit({},
    function(assert) {
      "Test that title titlecases input.";
      var words = ['hey','there','how','are','you',"you're",'1st','lol'],
          sentence = words.sort(function() {
              return Math.random() > 0.5;
          }).join(' ');

      var tpl = new plate.Template("{{ sentence|title }}");

      tpl.render({sentence:sentence}, assert.async(function(err, data) {
        var bits = data.split(/\s+/g);
        while(bits.length) {
          assert.ok((/^[A-Z0-9]{1}[a-z']+/g).test(bits.pop()));
        }
      }));
    }
);

exports.TestOfStripTags = platoon.unit({},
    function(assert) {
      "Test that striptags removes all HTML tags no matter how cool they are.";
      var testData =[
      '<div class="versionadded">',
      '<span class="title">New in Django 1.1.2:</span> <a class="reference internal" href="../../../releases/1.1.2/"><em>Please, see the release notes</em></a></div>',
      '<p>In the Django 1.1.X series, this is a no-op tag that returns an empty string for',
      'future compatibility purposes.  In Django 1.2 and later, it is used for CSRF',
      'protection, as described in the documentation for <a class="reference internal" href="../../contrib/csrf/"><em>Cross Site Request',
      'Forgeries</em></a>.</p>',
      '</div>'
      ].join('\n');
      var tpl = new plate.Template('{{ text|striptags }}');

      tpl.render({text:testData}, assert.async(function(err, data) {
          // fail if you see a tag.
          assert.fail((/<[^>]*?>/g).test(data));
      }));
    }
);

exports.TestOfTruncateChars = platoon.unit({},
    function(assert) {
      "Test that a string of characters gets truncated properly.";
      var input = 'This is a collection of words.';

      var tpl = new plate.Template('{{ input|truncatechars:8 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is ...');
      }));

      var tpl = new plate.Template('{{ input|truncatechars:20 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a collection...');
      }));

      var tpl = new plate.Template('{{ input|truncatechars:200 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a collection of words....');
      }));
    },
    function(assert) {
      "Test that a busted number doesn't double call the callback.";
      var input = 'This is a collection of words.';

      var tpl = new plate.Template('{{ input|truncatechars:abc }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a collection of words.');
      }));
    }
);

exports.TestOfTruncateWords = platoon.unit({},
    function(assert) {
      "Test that a string of words gets truncated properly.";
      var input = 'This is a collection of words.';

      var tpl = new plate.Template('{{ input|truncatewords:3 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a...');
      }));

      var tpl = new plate.Template('{{ input|truncatewords:0 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, '...');
      }));

      var tpl = new plate.Template('{{ input|truncatewords:8 }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a collection of words....');
      }));
    },
    function(assert) {
      "Test that a busted number doesn't double call the callback.";
      var input = 'This is a collection of words.';

      var tpl = new plate.Template('{{ input|truncatewords:abc }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, 'This is a collection of words.');
      }));
    }
);

exports.TestOfUnorderedList = platoon.unit({},
    function(assert) {
      "Test that unordered list... makes unordered lists. Awesome ones.";
      var input = ['States', ['Kansas', ['Lawrence', 'Topeka'], 'Illinois']],
          output = '<li>States<ul><li>Kansas<ul><li>Lawrence</li><li>Topeka</li></ul></li><li>Illinois</li></ul></li>';

      var tpl = new plate.Template('{{ input|unordered_list }}'),
          context = {input:input};

      tpl.render(context, assert.async(function(err, data) {
        assert.equal(data, output);
      }));
    }
);

exports.TestOfURLEncode = platoon.unit({},
    function(assert) {
      "Test that urlencode encodes all appropriate characters by using the built-in escape function.";
      var stringOfEverything = (function() {
          var out = [];
          while(out.length < 256) { out.push(String.fromCharCode(out.length)); }
          return out.join('');
        })(),
        tpl = new plate.Template('{{ str|urlencode }}');

      tpl.render({str:stringOfEverything}, assert.async(function(err, data) {
        assert.equal(data, escape(stringOfEverything));
      }));
    }
);

exports.TestOfURLize = platoon.unit({},
    function(assert) {
      "Test that urlize will turn urls of the form http://whatever.com/whatever, https://whatever.org/whatever into links.";
      var links = ['https://google.com/', 'http://neversaw.us/media/blah.png'],
          para = ['hey there i love ', links[0], ' and(',links[1],')'].join(''),
          result = 'hey there i love <a href="'+links[0]+'">'+links[0]+'</a> and(<a href="'+links[1]+'">'+links[1]+'</a>)';

      var tpl = new plate.Template('{{ para|urlize }}');

      tpl.render({para:para}, assert.async(function(err, data) {
        assert.equal(data, result);
      }));
    }
);

exports.TestOfURLizeTrunc = platoon.unit({});

exports.TestOfWordCount = platoon.unit({},
    function(assert) {
      "Assert that wordcount counts the number of words.";
      var lorem = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.',
          count = lorem.split(/\s+/g).length,
          tpl = new plate.Template("{{ lorem|wordcount }}");

      tpl.render({lorem:lorem}, assert.async(function(err, data) {
        assert.equal(data, count.toString());
      }));
    }
);

exports.TestOfWordWrap = platoon.unit({},
    function(assert) {
      "Assert that wordwrap wraps lines at a given number.";
      var lorem = 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.',
          values = [1,2,3,4,5,6,7,8,9],
          tpl = new plate.Template("{% for value in values %}{{ lorem|wordwrap:value }}:{% endfor %}");

      tpl.render({lorem:lorem, values:values}, assert.async(function(err, data) {
        var bits = data.split(':').slice(0, -1);
        for(var i = 0, len = bits.length; i < len; ++i) {
          var lilbits = bits[i].split('\n'),
              max = 0,
              val;
          while(lilbits.length) {
            val = lilbits.pop().split(/\s+/g).length;
            max = max < val ? val : max;
          }
          assert.ok(max <= values[i]);
        }
      }));
    }
);

exports.TestOfYesNo = platoon.unit({},
    function(assert) {
      "Test that the yesno filter coerces values into truthy,falsy";
      var tpl = new plate.Template('{% for value in values %}{{ value|yesno:"truthy,falsy" }}\n{% endfor %}'),
          context = {
            values:[true, 1, {}, [], false, null, undefined]
          };
      tpl.render(context, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1);
        for(var i = 0, len = bits.length; i < len; ++i) {
          var mode = context.values[i] ? 'truthy' : 'falsy';
          assert.equal(bits[i], mode);
        }
      }));
    },
    function(assert) {
      "Test that the yesno filter coerces values into true,false,maybe";
      var tpl = new plate.Template('{% for value in values %}{{ value|yesno:"truthy,falsy,maybe" }}\n{% endfor %}'),
          context = {
            values:[true, 1, {}, [], false, null, undefined]
          };
      tpl.render(context, assert.async(function(err, data) {
        var bits = data.split('\n').slice(0, -1);
        for(var i = 0, len = bits.length; i < len; ++i) {
          var mode = context.values[i] ? 'truthy' : context.values[i] === false ? 'falsy' : 'maybe';
          assert.equal(bits[i], mode);
        }
      }));
    }
);

  })(Function(), testrunner.make("./tests/filters.js"));(function (require, exports) {
    ;if(typeof window === 'undefined') {
  var plate = require('../index')
    , utils = require('../lib/utils')
    , platelib = require('../lib/libraries')
    , platoon = require('platoon')
} else {
  var plate = window.plate
    , platoon = window.platoon
  var platelib = plate.libraries
    , utils = plate.utils
}

var format = utils.format

exports.TestForTag = platoon.unit({},
    function(assert) {
        "Test that for is enabled by default";
        var tpl = new plate.Template("{% for x in y %}{% empty %}{% endfor %}");

        assert.doesNotThrow(function() {
            tpl.render({}, function(err, data) {});
        });
    },
    function(assert) {
        "Test that for does not bubble errors if it cannot find the appropriate arrayVar";
        var tpl = new plate.Template("{% for x in y %}{% endfor %}");

        tpl.render({}, assert.async(function(err, data) {
            assert.strictEqual(err, null);
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.counter";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.counter }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], j+1);
            }
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.counter0";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.counter0 }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], j);
            }
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.revcounter";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.revcounter }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], size-j);
            }
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.revcounter0";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.revcounter0 }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], size-(j+1));
            }
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.first";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.first }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], j === 0 ? 'true' : 'false');
            }
        }));
    },
    function(assert) {
        "Test that entering a for loop provides the forloop.last";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{{ forloop.last }}\n{% endfor %}");
        context.y = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size);
            for(var j = 0; j < size; ++j) {
                assert.equal(items[j], j === size-1 ? 'true' : 'false');
            }
        }));
    },
    function(assert) {
        "Test that entering a nested forloop provides forloop.parentloop";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push(~~(Math.random()*10));
        }
        var tpl = new plate.Template("{% for x in y %}{% for a in b %}{{ forloop.parentloop.counter }}:{{ forloop.counter }}\n{% endfor %}{% endfor %}");
        context.y = arr;
        context.b = arr;
        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);
            assert.equal(items.length, size*size);
            for(var x = 0; x < size; ++x) {
                for(var y = 0; y < size; ++y) {
                    assert.equal(items[x*size + y], [x+1,y+1].join(':'));
                }
            }
        }));
    },
    function(assert) {
        "Test that for unpacks variables as needed";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push([~~(Math.random()*10), ~~(Math.random()*10)]);
        }
        var tpl = new plate.Template("{% for x, y in z %}{{ x }},{{ y }}\n{% endfor %}"),
            context = {
                z:arr
            };

        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);

            assert.strictEqual(err, null);
            assert.equal(items.length, size);
            
            for(i = 0; i < size; ++i) {
                assert.equal(items[i], arr[i].join(','));
            }
        }));
    },
    function(assert) {
        "Test that for can reverse the contents of an array prior to iteration";
        var size = ~~(Math.random()*10)+1,
            arr = [],
            context = {};
        for(var i = 0; i < size; ++i) {
            arr.push([~~(Math.random()*10), ~~(Math.random()*10)]);
        }
        var tpl = new plate.Template("{% for x, y in z reversed %}{{ x }},{{ y }}\n{% endfor %}"),
            context = {
                z:arr
            };

        tpl.render(context, assert.async(function(err, data) {
            var items = data.split('\n').slice(0,-1);

            assert.strictEqual(err, null);
            assert.equal(items.length, size);
 
            for(i = 0; i < size; ++i) {
                assert.equal(items[i], arr[(size-1)-i].join(','));
            }
        }));
    }
);

exports.TestWithTag = platoon.unit({},
    function(assert) {
        "Test that the with is enabled by default";
        assert.doesNotThrow(function() {
            var tpl = new plate.Template("{% with x as y %}\n\n{% endwith %}");
            tpl.render({}, function(){});
        });
    },
    function(assert) {
        "Test that with adds the variable into context";
        var context = {
            'value':~~(Math.random()*10)
        };
        var tpl = new plate.Template("{% with value as othervalue %}{{ othervalue }}{% endwith %}");
        tpl.render(context, assert.async(function(err, data) {
            assert.strictEqual(err, null);
            assert.equal(data, context.value.toString());
        }));
    },
    function(assert) {
        "Test that with does not leak context variables";
        var context = {
            'value':'hi'+~~(Math.random()*10),
            'othervalue':~~(Math.random()*10)+'yeah'
        };
        var tpl = new plate.Template("{% with value as othervalue %}{{ othervalue }}{% endwith %}{{ othervalue }}");
        tpl.render(context, assert.async(function(err, data) {
            assert.strictEqual(err, null);
            assert.equal(data, context.value.toString()+context.othervalue.toString());
        }));
    },
    function(assert) {
        "Test that an unclosed with statement throws an error";
        var tpl = new plate.Template("{% with x as y %}\n\n yeahhhhh");
        tpl.render({}, assert.async(function(err, data){
            assert.strictEqual(data, null);
            assert.isInstance(err, Error);
        }));
    }
);

exports.TestIfTag = platoon.unit({},
    function(assert) {
        "Test that if tag is enabled by default";
        var tpl = new plate.Template("{% if x %}{% endif %}");
        assert.doesNotThrow(function() {
            tpl.render({}, function(err, data) {});
        });
    },
    function(assert) {
        "Test that =, ==, and != work";
        var pairs = [[~~(Math.random()*10), ~~(10 + Math.random()*10)],
                    [3, 3],
                    ['string', 'string']],
            context = {
                pairs:pairs
            },
            tpl = new plate.Template("{% for lhs, rhs in pairs %}"+
                                     "{% if lhs = rhs %}={% else %}!={% endif %}\n"+
                                     "{% if lhs == rhs %}={% else %}!={% endif %}\n"+
                                     "{% if lhs != rhs %}!={% else %}={% endif %}\n"+
                                     "{% endfor %}"),
            expect = [
                '!=', '!=', '!=',
                '=', '=', '=',
                '=', '=', '='
            ].join('\n')+'\n';

        tpl.render(context, assert.async(function(err, data) {
            assert.strictEqual(expect, data);
        }));
    },
    function(assert) {
        "Test that in and not in work";
        var tpl = new plate.Template("{% for x,y,z in list %}{% if x in y %}y{% endif %}{% if x not in y %}n{% endif %}:{{ z }}\n{% endfor %}"),
            tests = [
                [[1,2], [1,2,3], 'n'],
                [[1,2], [[1,2],3], 'y'],
                [1, {1:'something'}, 'y'],
                ['hi', 'asahi', 'y'],
                ['no', 'yes', 'n']
            ];
        tpl.render({list:tests}, assert.async(function(err, data) {
            var items = data.split('\n').slice(0, -1);
            while(items.length) {
                var v = items.shift().split(':');
                assert.equal(v[0],v[1]);
            }
        }));
    },
    function(assert) {
        "Test that >, <, <=, and >= work";
        var pairs = [[~~(Math.random()*10), ~~(10 + Math.random()*10)],
                    [3, 3],
                    ['string', 'string']],
            context = {
                pairs:pairs
            },
            tpl = new plate.Template("{% for lhs, rhs in pairs %}"+
                                     "{% if lhs < rhs %}<{% else %}>={% endif %}\n"+
                                     "{% if lhs <= rhs %}<={% else %}>{% endif %}\n"+
                                     "{% if lhs > rhs %}>{% else %}<={% endif %}\n"+
                                     "{% if lhs >= rhs %}>={% else %}<{% endif %}\n"+
                                     "{% endfor %}"),
            expect = [
                '<', '<=', '<=', '<',
                '>=', '<=', '<=', '>=',
                '>=', '<=', '<=', '>='
            ].join('\n')+'\n';

        tpl.render(context, assert.async(function(err, data) {
            assert.strictEqual(expect, data);
        }));
    }
);


exports.TestExtendsAndBlockTags = platoon.unit({},
    function(assert) {
        "Test that extends does not trigger a parser error.";
        var tpl = new plate.Template("{% extends whatever %}");
        assert.doesNotThrow(function() {
            tpl.getNodeList();
        });
    },
    function(assert) {
        "Test that extending a template produces super great results.";
        var base = new plate.Template("hey {% block who %}<b>gary</b>{% endblock %}, how are you?"),
            child = new plate.Template("{% extends base %}{% block who %}{{ block.super }} busey{% endblock %}"),
            ctxt = { base:base };
        child.render(ctxt, function(err, data) {
            assert.equal(data, "hey <b>gary</b> busey, how are you?");
        });
    },
    function(assert) {
        "Test that multilevel extending works";
        var base = new plate.Template("hey {% block firstname %}{% endblock %} {% block lastname %}{% endblock %}"+
                                        ", {% block greeting %}hi there{% endblock %}"),
            child1 = new plate.Template("{% extends base %}{% block firstname %}gary{% endblock %}"),
            child2 = new plate.Template("{% extends child %}{% block firstname %}{{ block.super }} m.{% endblock %}"+
                                        "{% block lastname %}busey{% endblock %}"),
            context = {
                base:base,
                child:child1
            };
        child2.render(context, function(err, data) {
            assert.equal(data, "hey gary m. busey, hi there");
        });
    }
);

exports.TestIncludeTag = platoon.unit({},
    function(assert) {
        "Test that include does not trigger a parser error";
        var tpl = new plate.Template("{% include something %}");
        assert.doesNotThrow(function() {
            tpl.getNodeList();
        });
    },
    function(assert) {
        "Test that include will include the contents of the included template into the includer.";
        var random = "random-"+Math.random(),
            include = new plate.Template(random),
            tpl = new plate.Template("{% include tpl %}"),
            context = { tpl:include };
        tpl.render(context, function(err, data) {
            assert.equal(data, random);
        });
    },
    function(assert) {
        "Test that the loader plugin works with include";
        if(typeof window !== 'undefined')
          return;

        var loader = function(name, callback) {
                setTimeout(function() {
                    callback(null, new plate.Template(name));
                }, ~~(Math.random()*10));
            },
            pluginLib = function() {
                platelib.Library.call(this);
                this.register('loader', loader);
            },
            F = function(){};
        F.prototype = platelib.Library.prototype;
        pluginLib.prototype = new F();

        var name = "name-"+Math.random(),
            tpl = new plate.Template("{% include \""+name+"\" %}", {
                plugin_library:new pluginLib()
            });
        tpl.render({}, assert.async(function(err, data) {
            assert.equal(data, name);
        }));
    }
);

exports.TestCommentTag = platoon.unit({},
    function(assert) {
        "Test that comment does not trigger a parser error";
        var tpl = new plate.Template("{% comment %}{% endcomment %}");
        assert.doesNotThrow(function() {
            tpl.getNodeList();
        });
    },
    function(assert) {
        "Test that comment omits all items wrapped inside the comment block.";
        var tpl = new plate.Template("{% comment %}asdf{% endcomment %}");
        tpl.render({}, assert.async(function(err, data) {
            assert.equal(data, '');
        }));
    }
);

exports.TestNowTag = platoon.unit({},
    function(assert) {
      "test that now defaults to now N y, J"

      var tpl = new plate.Template('{% now %}')
        , now = format(new Date, 'N j, Y')

      tpl.render({}, assert.async(function(err, data) {
        assert.equal(data, now)
      })) 

    },
    function(assert) {
      "test that now can be configured with another argument";

      var tpl = new plate.Template('{% now "jS o\\f F" %}')
        , now = format(new Date, 'jS o\\f F')

      tpl.render({}, assert.async(function(err, data) {
        assert.equal(data, now)
      })) 

    }
);


  })(Function(), testrunner.make("./tests/tags.js"));(function (require, exports) {
    ;
if(typeof window === 'undefined') {
  var plate = require('../index'),
      path = require('path'),
      platoon = require('platoon'),
      libraries = require('../lib/libraries'),
      filesystem = require('../lib/plugins/loaders/filesystem');

  exports.TestOfFilesystemLoader = platoon.unit({}, 
      function(assert) {
          "Test that the filesystem loader returns templates from filesystem.";
          var loader = new filesystem.Loader(
                  [path.join(process.cwd(), 'tests', 'templates')]
              );
          loader.lookup('test.html', assert.async(function(err, template) {
              assert.isInstance(template, plate.Template);
          }));
      },
      function(assert) {
          "Test that the filesystem loader works with the extends tag";
          var lib = new libraries.Library(),
              loader = new filesystem.Loader( 
                  [path.join(process.cwd(), 'tests', 'templates')]
              );

          lib.register('loader', loader.getPlugin());
          loader.setTemplateCreation(function(data) {
              return new plate.Template(data, {
                  plugin_library:lib
              });
          });

          loader.lookup('test_child.html', assert.async(function(err, template) {
              assert.isInstance(template, plate.Template);
              template.render({}, assert.async(function(err, data) {
                  assert.equal(data, "hello world!\n");
              }));
          }));
      }
  );
}

  })(Function(), testrunner.make("./tests/plugins.js"));(function (require, exports) {
    ;if(typeof window === 'undefined') {
  var plate = require('../index')
    , utils = require('../lib/utils')
    , platelib = require('../lib/libraries')
    , nodes = require('../lib/nodes')
    , platoon = require('platoon')
} else {
  var plate = window.plate
    , platoon = window.platoon
  var platelib = plate.libraries
    , nodes = plate.nodes
}

exports.TestTemplateAPI = platoon.unit({},
    function(assert) {
        "Test the exception cases of plate.Template.";
        assert.throws(TypeError, function() {
            var tpl = new plate.Template(2);
        });
        assert.throws(TypeError, function() {
            var tpl = new plate.Template();
        });
        
        var tplstr = "random-"+Math.random(),
            tpl = new plate.Template(tplstr);

        assert.throws(TypeError, function() {
            tpl.render();
        });

        assert.throws(TypeError, function() {
            tpl.render("");
        });

        assert.throws(TypeError, function() {
            tpl.render(Math.random());
        });

        tpl.render({}, function(err, data) {
            assert.fail(err);
            assert.equal(tplstr, data);
        });

        tpl.render(new plate.Context({}), assert.async(function(err, data) {
            assert.fail(err);
            assert.equal(data, tplstr);
        }));
    },
    function(assert) {
        "Test that encountering a {% tag %} will lookup that tag in the provided library";
        var lib = new platelib.Library(),
            name = "random_"+~~Math.random(),
            value = Math.random().toString(),
            creationFunction = function(token, parser) {
                return {
                    render:function(context, callback) {
                        callback(null, value);
                    }
                };
            };
        lib.register(name, creationFunction);
        var tpl = new plate.Template("{% "+name+" %}", {tag_library:lib});
        tpl.render({}, assert.async(function(err, data) {
            assert.equal(data, value);
        }));
    },
    function(assert) {
        "Test that filter nodes render as expected.";
        var testContext = {
            value:Math.random().toString(),
            deep:{
                value:Math.random().toString(),
                method:function(callback) {
                    return "lobsters";
                },
                delayed:function(callback) {
                    setTimeout(function() {
                        callback(null, "delayed");
                    }, 10);
                }
            }
        };
        var tplValue = new plate.Template("{{ value }}"),
            tplDeep = new plate.Template("{{ deep.value }}"),
            tplMethod = new plate.Template("{{ deep.method }}");
            tplDelayed = new plate.Template("{{ deep.delayed }}");

        tplValue.render(testContext, function(err, data) {
            assert.equal(err, null);
            assert.equal(data, testContext.value);
        });

        tplDeep.render(testContext, function(err, data) {
            assert.equal(err, null);
            assert.equal(data, testContext.deep.value);
        });

        tplMethod.render(testContext, function(err, data) {
            assert.equal(err, null);
            assert.equal(data, testContext.deep.method());
        });

        tplDelayed.render(testContext, assert.async(function(err, data) {
            assert.equal(err, null);
            assert.equal('delayed', data);
        }));
    },
    function(assert) {
        "Test that hitting an unknown tag triggers an error.";
        var tpl = new plate.Template("{% lol dne %}");
        tpl.render({}, assert.async(function(err, data) {
            assert.strictEqual(data, null);
            assert.isInstance(err, Error); 
        }));
    }
);

exports.TestTemplateMetaAPI = platoon.unit({},
    function(assert) {
      "Test that autoregistration of the tag library works as expected.";
      var expected = ~~(Math.random()*100);
      var tag = {
        render:function(context, ready) {
          ready(null, ''+expected);
        }
      }; 
      plate.Template.Meta.registerTag('lolwut', function() { return tag; });

      assert.doesNotThrow(function() {
        var tpl = new plate.Template('{% lolwut %}');
        tpl.render({}, assert.async(function(err, data) {
          assert.equal(data, ''+expected);
        }));
      });
    },
    function(assert) {
      "Test that autoregistration of the filter library works as expected.";
      var expected = ~~(Math.random()*100);
      var testFilter = function(ready, input) {
        ready(null, ''+expected);
      };
      plate.Template.Meta.registerFilter('lolol', testFilter);

      assert.doesNotThrow(function() {
        var tpl = new plate.Template('{{ anything|lolol }}');

        tpl.render({}, assert.async(function(err, data) {
          assert.equal(data, ''+expected);
        }));
      });
    },
    function(assert) {
      "Test that autoregistration of the plugin library works as expected.";
      var expected = ~~(Math.random()*100);
      var plugin = function() {
        return ''+expected;
      };
      plate.Template.Meta.registerPlugin('test_plugin', plugin);

      var TestNode = function(test_plugin){ this.plugin = test_plugin; };
      TestNode.prototype = new nodes.Node;

      TestNode.prototype.render = function(context, ready) {
        ready(null, this.plugin());
      };
      TestNode.parse = function(contents, parser) {
        var test_plugin = parser.pluginLibrary.lookup('test_plugin');
        return new TestNode(test_plugin);
      };
      plate.Template.Meta.registerTag('test_plugin_tag', TestNode.parse);

      assert.doesNotThrow(function() {
        var tpl = new plate.Template('{% test_plugin_tag %}');
        tpl.render({}, function(err, data) {
          assert.equal(data, ''+expected);
        });
      });


    }
);

  })(Function(), testrunner.make("./tests/plate.js"));; return testrunner;})(platoon.makeHTMLTestRunner()).run()</script>
  
